;   Scunak: A Mathematical Assistant System
;   Copyright (C) 2006 Chad E Brown (cebrown2323@yahoo.com)
;
;   This program is free software; you can redistribute it and/or modify
;   it under the terms of the GNU General Public License as published by
;   the Free Software Foundation; either version 2 of the License, or
;   (at your option) any later version.
;
;   This program is distributed in the hope that it will be useful,
;   but WITHOUT ANY WARRANTY; without even the implied warranty of
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;   GNU General Public License for more details.
;
;   You should have received a copy of the GNU General Public License along
;   with this program; if not, write to the Free Software Foundation, Inc.,
;   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

; Author: Chad E Brown
; August-November, 2005
; declaring global constants, claims, abbrevs

(defvar *universal-set* nil)
(defvar *universal-set-pf* nil)

(defvar *verbose* 2)
(defvar *timestamp* 0)
(defvar *global-sigma* nil)
(defvar *allow-masking* t)
(defvar *allow-constants* t)
(defvar *check-simple-types* nil)
(defvar *auto-gen-congruence* t)
(defvar *congruences-stage* 0) ; 0 start, 1 eq and equiv are declared, 2 congruences are declared for all constants

(defvar *skip-proofs* nil) ; if t, proofs are not checked and are left as claims instead of abbrevs

(defun constname-p (name)
  (get name 'CONST))

(defun abbrevname-p (name)
  (get name 'ABBREV))

(defun claimname-p (name)
  (get name 'CLAIM))

(defun usedname-p (name)
  (or (constname-p name)
      (abbrevname-p name)
      (claimname-p name)))

(defun newconst (name dtype &optional authors)
  (unless (or *allow-constants* (get name 'auto-gen))
    (fail (format nil "No more constants can be declared.  You probably want to make a claim?")))
  (when (and (eq *allow-constants* 'WARN) (not (get name 'auto-gen)))
    (format t "WARNING: Declaring Constant ~d~%"))
  (unless (or *allow-masking* (get name 'auto-gen))
    (when (constname-p name)
      (fail (format nil "There is already a constant named ~d." name)))
    (when (abbrevname-p name)
      (fail (format nil "There is already an abbreviation named ~d." name)))
    (when (claimname-p name)
      (fail (format nil "There is already an claim named ~d." name))))
  (when (and *allow-masking* (not (get name 'auto-gen)))
    (when (constname-p name)
      (format t "WARNING: Shadowing constant ~d.~%" name))
    (when (abbrevname-p name)
      (format t "WARNING: Shadowing abbreviation ~d.~%" name))
    (when (claimname-p name)
      (format t "WARNING: Shadowing claim ~d.~%" name)))
  (unless (or (not *check-simple-types*) (simply-valid-p nil dtype))
    (fail (format nil "type is not simply valid" name dtype)))
  (unless (beta-normal-type-p dtype)
    (fail "Given type of ... is not beta-normal." name dtype))
  (setq dtype (normalize-type dtype)) ; eta normalize
  (multiple-value-bind
   (foo fail)
   (deptype2-p dtype)
   (unless foo
     (fail "Given type of ... is not a valid dependent type of order 2." name dtype fail)))
;    (logtex
;     (format nil "New Constant~%${\\mbox{\\tt ~d}} : ~d$~2%" name (dtype-direct-latex dtype)))
    (when (> *verbose* 5)
      (format t "% New Constant~%${\\mbox{\\tt ~d}} : ~d$~2%"
	      (name-to-latex-string name) (dtype-direct-latex dtype)))
    (setf (get name 'const-authors) authors)
    (newconst-q name dtype))

(defun newabbrev (name dtype defn &optional type-authors defn-authors)
  (unless (or *allow-masking* (get name 'auto-gen))
    (when (constname-p name)
      (fail (format nil "There is already a constant named ~d." name)))
    (when (abbrevname-p name)
      (fail (format nil "There is already an abbreviation named ~d." name)))
    (when (claimname-p name)
      (fail (format nil "There is already an claim named ~d." name))))
  (when (and *allow-masking* (not (get name 'auto-gen)))
    (when (constname-p name)
      (format t "WARNING: Shadowing constant ~d.~%" name))
    (when (abbrevname-p name)
      (format t "WARNING: Shadowing abbreviation ~d.~%" name))
    (when (claimname-p name)
      (format t "WARNING: Shadowing claim ~d.~%" name)))
  (unless (or (not *check-simple-types*) (simply-valid-p nil dtype))
    (fail (format nil "type is not simply valid" name dtype)))
  (unless (or (not *check-simple-types*) (has-simple-type nil defn (typeerase dtype)))
    (fail (format nil "term is not of erased simple type" name defn (typeerase dtype))))
  (unless (beta-normal-type-p dtype)
    (fail "Given type of ... is not beta normal." name dtype))
  (setq dtype (normalize-type dtype))
  (multiple-value-bind
   (foo fail)
   (deptype2-p dtype)
   (unless foo
     (fail "Given type of ... is not a valid dependent type of order 2." name fail)))
  (if (and *skip-proofs* (dtype-returns-pf-p dtype))
      (progn
	(setf (get name 'claim-authors) type-authors)
	(newclaim-q name dtype)
	)
    (progn
  (unless (beta-normal-term-p defn)
    (fail "Given defn of ... is not beta normal." name defn))
  (setq defn (normalize defn))
  (unless (ctx-term-type-p *emptyctx* defn dtype)
    (fail "Defn of ... is not of dependent type." name defn dtype))
;  (logtex (format nil "New Abbrev ${\\mbox{\\bf ~d}} : ~d$~%$ = ~d$~2%"
;		    name
;		    (dtype-direct-latex dtype)
;		    (term-direct-latex defn)))
    (when (> *verbose* 5)
      (format t "% New Abbrev~%${\\mbox{\\bf ~d}} : ~d$~%$ = ~d$~2%"
	      (name-to-latex-string name)
	      (dtype-direct-latex dtype)
	      (term-direct-latex defn)))
    (setf (get name 'abbrev-type-authors) type-authors)
    (setf (get name 'abbrev-defn-authors) defn-authors)
    (newabbrev-q name dtype defn)
    t)))

(defun newclaim (name dtype &optional authors)
  (unless (or *allow-masking* (get name 'auto-gen))
    (when (constname-p name)
      (fail (format nil "There is already a constant named ~d." name)))
    (when (abbrevname-p name)
      (fail (format nil "There is already an abbreviation named ~d." name)))
    (when (claimname-p name)
      (fail (format nil "There is already an claim named ~d." name))))
  (when (and *allow-masking* (not (get name 'auto-gen)))
    (when (constname-p name)
      (format t "WARNING: Shadowing constant ~d.~%" name))
    (when (abbrevname-p name)
      (format t "WARNING: Shadowing abbreviation ~d.~%" name))
    (when (claimname-p name)
      (format t "WARNING: Shadowing claim ~d.~%" name)))
  (unless (or (not *check-simple-types*) (simply-valid-p nil dtype))
    (fail (format nil "type is not simply valid" name dtype)))
  (unless (beta-normal-type-p dtype)
    (fail "Given type of is not beta normal." name dtype))
  (setq dtype (normalize dtype))
  (multiple-value-bind
   (foo fail)
   (deptype2-p dtype)
   (unless foo
     (fail "Given type ... of ... is not a valid dependent type of order 2." dtype name fail)))
;    (logtex
;     (format nil "New Claim~%${\\mbox{\\cal ~d}} : ~d$~2%" name (dtype-direct-latex dtype)))
    (when (> *verbose* 5)
      (format t "% New Claim~%${\\mbox{\\cal ~d}} : ~d$~2%" (name-to-latex-string name) (dtype-direct-latex dtype)))
    (setf (get name 'claim-authors) authors)
    (newclaim-q name dtype))

(defun claim2abbrev (name defn &optional defn-authors)
  (unless (claimname-p name)
    (fail "... is not a claim" name))
  (unless (or (not *check-simple-types*) (has-simple-type nil defn (typeerase (get name 'dbtype))))
    (fail (format nil "term is not of erased simple type" name defn (typeerase dtype))))
  (unless (beta-normal-term-p defn)
    (fail "Given defn of ... is not beta normal." name defn))
  (setq defn (normalize defn))
  (let ((dtype (get name 'dbtype)))
    (unless (ctx-term-type-p *emptyctx* defn dtype)
      (fail "Defn of ... is not of dependent type of claim." name defn dtype))
    (ensure-timestamp-before name defn (get name 'timestamp))
;  (logtex (format nil "Claim Resolved to Abbrev ${\\mbox{\\bf ~d}} : ~d$~%$ = ~d$~2%"
;		    name
;		    (dtype-direct-latex dtype)
;		    (term-direct-latex defn)))
    (when (> *verbose* 5)
      (format t "% Claim Resolved to Abbrev~%${\\mbox{\\bf ~d}} : ~d$~%$ = ~d$~2%"
	      (name-to-latex-string name)
	      (dtype-direct-latex dtype)
	      (term-direct-latex defn)))
    (setf (get name 'abbrev-type-authors) (get name 'claim-authors))
    (setf (get name 'abbrev-defn-authors) defn-authors)
    (claim2abbrev-q name defn)
    t))

(defun newconst-q (name dtype)
  (setf (get name 'const) t)
  (setf (get name 'dbtype) dtype)
  (setf (get name 'timestamp) (incf *timestamp*))
  (push name *global-sigma*)
  (extra-sig-info name)
  name)

(defun newabbrev-q (name dtype defn)
  (setf (get name 'abbrev) t)
  (setf (get name 'dbtype) dtype)
  (setf (get name 'defn) defn)
  (setf (get name 'timestamp) (incf *timestamp*))
  (push name *global-sigma*)
  (extra-sig-info name)
  name)

(defun newclaim-q (name dtype)
  (setf (get name 'claim) t)
  (setf (get name 'dbtype) dtype)
  (setf (get name 'timestamp) (incf *timestamp*))
  (push name *global-sigma*)
  (extra-sig-info name)
  name)

(defun claim2abbrev-q (name defn)
  (setf (get name 'claim) nil)
  (setf (get name 'abbrev) t)
  (setf (get name 'defn) defn)
  (extra-sig-info name)
  name)

(defun eq-declared-p ()
  (and (get '|eq| 'dbtype)
       (equal (get '|eq| 'dbtype) '(DPI OBJ DPI OBJ . PROP))
       (get '|eqCE| 'dbtype)
       (equal (get '|eqCE| 'dbtype)
	      '(DPI (DPI OBJ . PROP) DPI (DCLASS . 0) DPI (DCLASS . 1) DPI
		    (DPI (DCLASS . 2) . PROP) DPI (PF APP (APP |eq| FST . 2) FST . 1)
		    DPI (PF APP 1 . 3) PF APP 2 . 3))
       (get '|eqE| 'dbtype)
       (equal (get '|eqE| 'dbtype)
	      '(DPI OBJ DPI OBJ DPI (DPI OBJ . PROP) DPI (PF APP (APP |eq| . 2) . 1)
		    DPI (PF APP 1 . 3) PF APP 2 . 3))
       (get '|eqI| 'dbtype)
       (equal (get '|eqI| 'dbtype) '(DPI OBJ PF APP (APP |eq| . 0) . 0))
       (get '|symeq| 'dbtype)
       (equal (get '|symeq| 'dbtype)
	      '(DPI OBJ DPI OBJ DPI (PF APP (APP |eq| . 1) . 0) PF APP (APP |eq| . 1)
		    . 2))
       (get '|transeq| 'dbtype)
       (equal (get '|transeq| 'dbtype)
	      '(DPI OBJ DPI OBJ DPI OBJ DPI (PF APP (APP |eq| . 2) . 1) DPI
		    (PF APP (APP |eq| . 2) . 1) PF APP (APP |eq| . 4) . 2))
       (get '|symtrans1eq| 'dbtype)
       (equal (get '|symtrans1eq| 'dbtype)
	      '(DPI OBJ DPI OBJ DPI OBJ DPI (PF APP (APP |eq| . 2) . 1) DPI
		    (PF APP (APP |eq| . 1) . 2) PF APP (APP |eq| . 4) . 2))
       (get '|boxeq| 'dbtype)
       (equal (get '|boxeq| 'dbtype)
	      '(DPI OBJ DPI OBJ DPI OBJ DPI OBJ DPI (PF APP (APP |eq| . 3) . 2) DPI
		    (PF APP (APP |eq| . 2) . 1) DPI (PF APP (APP |eq| . 4) . 2) PF APP
		    (APP |eq| . 6) . 4))
       (get '|equiv| 'dbtype)
       (equal (get '|equiv| 'dbtype) '(DPI PROP DPI PROP . PROP))
       (get '|equivI| 'dbtype)
       (equal (get '|equivI| 'dbtype) 
	      '(DPI PROP DPI PROP DPI (DPI (PF . 1) PF . 1) DPI (DPI (PF . 1) PF . 3)
		    PF APP (APP |equiv| . 3) . 2))
       (get '|reflequiv| 'dbtype)
       (equal (get '|reflequiv| 'dbtype)
	      '(DPI PROP PF APP (APP |equiv| . 0) . 0))
       (get '|symequiv| 'dbtype)
       (equal (get '|symequiv| 'dbtype)
	      '(DPI PROP DPI PROP DPI (PF APP (APP |equiv| . 1) . 0) PF APP
		    (APP |equiv| . 1) . 2))
       (get '|equivEimp1| 'dbtype)
       (equal (get '|equivEimp1| 'dbtype)
	      '(DPI PROP DPI PROP DPI (PF APP (APP |equiv| . 1) . 0) DPI (PF . 2) PF . 2))
       (get '|equivEimp2| 'dbtype)
       (equal (get '|equivEimp2| 'dbtype)
	      '(DPI PROP DPI PROP DPI (PF APP (APP |equiv| . 1) . 0) DPI (PF . 1) PF
		    . 3))
       (get '|boxequiv| 'dbtype)
       (equal (get '|boxequiv| 'dbtype)
	      '(DPI PROP DPI PROP DPI PROP DPI PROP DPI (PF APP (APP |equiv| . 3) . 2)
		    DPI (PF APP (APP |equiv| . 2) . 1) DPI
		    (PF APP (APP |equiv| . 4) . 2) PF APP (APP |equiv| . 6) . 4))
       ))

(defun extra-sig-info (name)
  (let ((upcasename (read-from-string (format nil "~d" name))))
    (unless (or (not (symbolp upcasename)) (eq upcasename name) (member upcasename *global-sigma*))
      (setf (get upcasename 'alias) name)))
  (let ((tp (get name 'dbtype)))
    (when (and (dpi-p tp) (obj-p (dpi-dom tp)) (pf-p (dpi-cod tp))
	       (app-p (pf-prop (dpi-cod tp)))
	       (app-p (app-func (pf-prop (dpi-cod tp))))
	       (eq (app-func (app-func (pf-prop (dpi-cod tp)))) '|in|)
	       (equal (app-arg (pf-prop (dpi-cod tp))) 0)
	       (symbolp (app-arg (app-func (pf-prop (dpi-cod tp))))))
      (setq *universal-set* (app-arg (app-func (pf-prop (dpi-cod tp)))))
      (setq *universal-set-pf* name))
    (when (abbrevname-p name)
      (let ((defn (get name 'defn)))
	(case (classify-type tp)
	      (TFUNC
	       (let ((di (auto-gen-name name "F" 'defn-tfunc-fold))
		     (de (auto-gen-name name "U" 'defn-tfunc-unfold)))
		 (newconst di (tfunc-defn-intro-type name tp defn))
		 (newconst de (tfunc-defn-elim-type name tp defn))
		 (setf (get di 'auto-defn) (leibniz-defn-term tp))
		 (setf (get de 'auto-defn) (leibniz-defn-term tp))
		 (setf (get di 'timestamp) (+ (get name 'timestamp) 0.1))
		 (setf (get de 'timestamp) (+ (get name 'timestamp) 0.1))
		 )
	       (when (and *auto-gen-congruence* (eq-declared-p))
		 (auto-gen-tfunc-defn-eq name tp defn))
	       )
	      (FUNC 
	       (let ((di (auto-gen-name name "F" 'defn-func-fold))
		     (de (auto-gen-name name "U" 'defn-func-unfold)))
		 (newconst di (func-defn-intro-type name tp defn))
		 (newconst de (func-defn-elim-type name tp defn))
		 (setf (get di 'auto-defn) (leibniz-defn-term tp))
		 (setf (get de 'auto-defn) (leibniz-defn-term tp))
		 (setf (get di 'timestamp) (+ (get name 'timestamp) 0.1))
		 (setf (get de 'timestamp) (+ (get name 'timestamp) 0.1))
		 )
	       (when (and *auto-gen-congruence* (eq-declared-p))
		 (auto-gen-func-defn-eq name tp defn))
	       )
	      (RELN
	       (let ((di (auto-gen-name name "F" 'defn-reln-fold))
		     (de (auto-gen-name name "U" 'defn-reln-unfold)))
		 (newconst di (reln-defn-intro-type name tp defn))
		 (newconst de (reln-defn-elim-type name tp defn))
		 (setf (get di 'auto-defn) (reln-defn-term tp))
		 (setf (get de 'auto-defn) (reln-defn-term tp))
		 (setf (get di 'timestamp) (+ (get name 'timestamp) 0.1))
		 (setf (get de 'timestamp) (+ (get name 'timestamp) 0.1))
		 )
	       (when (and *auto-gen-congruence* (eq-declared-p))
		 (auto-gen-reln-defn-eq name tp defn))
	       ))))
    (when *auto-gen-congruence*
      (cond ((= *congruences-stage* 0)
	     (when (eq-declared-p)
	       (setq *congruences-stage* 1)
	       (dolist (c (reverse *global-sigma*))
		 (when (abbrevname-p c)
		   (let ((dtype (get c 'dbtype))
			 (defn (get c 'defn)))
		     (case (classify-type dtype)
			   (TFUNC (auto-gen-tfunc-defn-eq c dtype defn))
			   (FUNC (auto-gen-func-defn-eq c dtype defn))
			   (RELN (auto-gen-reln-defn-eq c dtype defn))))))))
	    ((= *congruences-stage* 1)
	     (unless (find-if #'(lambda (c)
				  (and (constname-p c)
				       (not (dtype-returns-pf-p (get c 'dbtype)))
				       (let ((cc (auto-gen-name c "Cong" nil)))
					 (or (not (get cc 'dbtype))
					     (not (equal (get cc 'dbtype)
							 (congruence-pf-type (get c 'dbtype) c)))))))
			      *global-sigma*)
	       (setq *congruences-stage* 2)
	       (when (> *verbose* 4)
		 (format t "All constants proven congruent, generating congruences for abbrevs.~%"))
	       (dolist (a (reverse *global-sigma*))
		 (cond ((abbrevname-p a)
			(auto-gen-abbrev-cong a))
		       ((claimname-p a)
			(auto-gen-claim-cong a))
		       (t nil)))
	       ))
	    (t
	     (cond ((constname-p name)
		    (unless (dtype-returns-pf-p tp)
		      (setq *congruences-stage* 1)
		      (when (> *verbose* 4)
			(format t "New constant to prove congruent.~%"))))
		   ((abbrevname-p name)
		    (auto-gen-abbrev-cong name))
		   ((claimname-p name)
		    (auto-gen-claim-cong name))
		   (t nil)))))
    (multiple-value-bind
     (ctx atp)
     (dtp-argctx tp)
     (cond ((pf-p atp) (setf (get name 'returns) 'PF))
	   ((dclass-p atp) (setf (get name 'returns) 'DCLASS))
	   ((obj-p atp) (setf (get name 'returns) 'OBJ))
	   ((prop-p atp) (setf (get name 'returns) 'PROP)))
     (let ((soctx (remove-if-not #'dpi-p ctx)))
       (when (all-strict-occs-type-p tp)
	 (setf (get name 'strict-occs) t))
       (if soctx
	   (if (remove-if #'(lambda (x) (dtype-returns-pf-p x)) soctx)
	       (if (equality-rule-type-p ctx atp tp)
		   (setf (get name 'equality-rule) t)
		 nil)
	     (setf (get name 'fo-unif-type) t))
	 (setf (get name 'fo-type) t))))))

(defun all-strict-occs-type-p (tp)
  (if (dpi-p tp)
      (if (dpi-p (dpi-dom tp))
	  (if (dtype-returns-pf-p (dpi-dom tp))
	      (all-strict-occs-type-p (dpi-cod tp))
	    (and (strict-occ-in-type-p 0 (dpi-cod tp))
		 (all-strict-occs-type-p (dpi-cod tp))))
	(all-strict-occs-type-p (dpi-cod tp)))
    t))

(defun strict-occ-in-type-p (n tp)
  (if (dpi-p tp)
      (or (strict-occ-in-type-p n (dpi-dom tp))
	  (strict-occ-in-type-p (1+ n) (dpi-cod tp)))
    (if (pf-p tp)
	(strict-occ-in-term-p n (pf-prop tp))
      (if (dclass-p tp)
	  (strict-occ-in-term-p n (dclass-pred tp))
	t))))

(defun strict-occ-in-term-p (n trm)
  (if (equal n trm)
      t
    (cond ((lam-p trm) nil)
	  ((pair-p trm)
	   (or (strict-occ-in-term-p n (pair-fst trm))
	       (strict-occ-in-term-p n (pair-snd trm))))
	  ((fst-p trm)
	   (strict-occ-in-term-p n (fst-arg trm)))
	  ((snd-p trm)
	   (strict-occ-in-term-p n (snd-arg trm)))
	  (t (strict-occ-in-app-p n trm)))))

(defun strict-occ-in-app-p (n trm)
  (if (app-p trm)
      (or (strict-occ-in-app-p n (app-func trm))
	  (strict-occ-in-term-p n (app-arg trm)))
    nil))

(defun equality-rule-type-p (ctx atp tp)
  (if (and (pf-p atp)
	   (app-p (pf-prop atp))
	   (numberp (app-func (pf-prop atp))))
      (let ((phi (app-func (pf-prop atp)))
	    (b (app-arg (pf-prop atp))))
	(if (and ctx
		 (pf-p (car ctx))
		 (app-p (pf-prop (car ctx)))
		 (equal (- phi 1) (app-func (pf-prop (car ctx)))))
	    (let ((a (app-arg (pf-prop (car ctx)))))
	      (if (ctx-depends-on-db (- phi 2) (cdr ctx))
		  nil
		t))
	  nil))
    nil))

(defun monadic-so-type-p (ctx atp)
  (not (find-if #'(lambda (x) (and (dpi-p x) (dpi-p (dpi-cod x)) (not (dtype-returns-pf-p x))))
		ctx)))

(defun diadic-so-type-p (ctx atp)
  (not (find-if #'(lambda (x) (and (dpi-p x) (dpi-p (dpi-cod x)) (dpi-p (dpi-cod (dpi-cod x))) (not (dtype-returns-pf-p x))))
		ctx)))

(defun ctx-depends-on-db (n ctx)
  (if (or (< n 0) (null ctx))
      nil
    (or (nintrm-type-p n (car ctx))
	(ctx-depends-on-db (- n 1) (cdr ctx)))))

(defun auto-gen-tfunc-defn-eq (name dtype defn)
  (multiple-value-bind
   (etp etrm)
   (tfunc-defn-eq-type name dtype defn (auto-gen-name name "U" 'defn-tfunc-unfold))
   (let ((deq (auto-gen-name name "Eq" 'defn-eq)))
     (newabbrev deq etp etrm)
     (setf (get deq 'timestamp) (+ (get name 'timestamp) 0.2)))))

(defun auto-gen-func-defn-eq (name dtype defn)
  (multiple-value-bind
   (etp etrm)
   (func-defn-eq-type name dtype defn (auto-gen-name name "U" 'defn-func-unfold))
   (let ((deq (auto-gen-name name "Eq" 'defn-eq)))
     (newabbrev deq etp etrm)
     (setf (get deq 'timestamp) (+ (get name 'timestamp) 0.2))
     )))

(defun auto-gen-reln-defn-eq (name dtype defn)
  (multiple-value-bind
   (etp etrm)
   (reln-defn-eq-type name dtype defn (auto-gen-name name "F" 'defn-reln-fold) (auto-gen-name name "U" 'defn-reln-unfold))
   (let ((deq (auto-gen-name name "Eq" 'defn-eq)))
     (newabbrev deq etp etrm)
     (setf (get deq 'timestamp) (+ (get name 'timestamp) 0.2))
     )))


; returns type and term
(defun tfunc-defn-eq-type (a dtype defn au)
  (if (dpi-p dtype)
      (multiple-value-bind
       (etp etrm)
       (tfunc-defn-eq-type (app (dbsubst a #'1+ 'ID) 0)
			   (dpi-cod dtype)
			   (gen-lam-body defn)
			   (app (dbsubst au #'1+ 'ID) 0)
			   )
       (values (dpi (dpi-dom dtype) etp)
	       (lam etrm)))
    (values (pf (app (app '|eq| (gen-pair-fst a)) (gen-pair-fst defn)))
	    (app-n au
		   (list (lam (app (app '|eq| (dbshift-n 1 (gen-pair-fst a))) 0))
			 (app '|eqI| (gen-pair-fst a)))))))
			 

; returns type and term
(defun func-defn-eq-type (a dtype defn au)
  (if (dpi-p dtype)
      (multiple-value-bind
       (etp etrm)
       (func-defn-eq-type (app (dbsubst a #'1+ 'ID) 0)
			  (dpi-cod dtype)
			  (gen-lam-body defn)
			  (app (dbsubst au #'1+ 'ID) 0)
			  )
       (values (dpi (dpi-dom dtype) etp) (lam etrm)))
    (values (pf (app (app '|eq| a) defn))
	    (app-n au
		   (list (lam (app (app '|eq| (dbshift-n 1 a)) 0))
			 (app '|eqI| a))))))

; returns type and term
(defun reln-defn-eq-type (a dtype defn af au)
  (if (dpi-p dtype)
      (multiple-value-bind
       (etp etrm)
       (reln-defn-eq-type (app (dbsubst a #'1+ 'ID) 0)
			  (dpi-cod dtype)
			  (gen-lam-body defn)
			  (app (dbsubst af #'1+ 'ID) 0)
			  (app (dbsubst au #'1+ 'ID) 0)
			  )
       (values (dpi (dpi-dom dtype) etp) (lam etrm)))
    (values (pf (app (app '|equiv| a) defn))
	    (app-n '|equivI|
		   (list a defn au af)))))

(defun tfunc-defn-elim-type (a dtype defn)
  (if (dpi-p dtype)
      (dpi (dpi-dom dtype)
	   (tfunc-defn-elim-type (app (dbsubst a #'1+ 'ID) 0)
				  (dpi-cod dtype)
				  (gen-lam-body defn)))
    (dpi *pred*
	 (dpi (pf (app 0 (gen-pair-fst (dbsubst a #'1+ 'ID))))
	      (pf (app 1 (gen-pair-fst (dbsubst defn #'2+ 'ID))))))))

(defun func-defn-elim-type (a dtype defn)
  (if (dpi-p dtype)
      (dpi (dpi-dom dtype)
	   (func-defn-elim-type (app (dbsubst a #'1+ 'ID) 0)
				 (dpi-cod dtype)
				 (gen-lam-body defn)))
    (dpi *pred*
	 (dpi (pf (app 0 (dbsubst a #'1+ 'ID)))
	      (pf (app 1 (dbsubst defn #'2+ 'ID)))))))

(defun func-defn-intro-type (a dtype defn)
  (if (dpi-p dtype)
      (dpi (dpi-dom dtype)
	   (func-defn-intro-type (app (dbsubst a #'1+ 'ID) 0)
				 (dpi-cod dtype)
				 (gen-lam-body defn)))
    (dpi *pred*
	 (dpi (pf (app 0 (dbsubst defn #'1+ 'ID)))
	      (pf (app 1 (dbsubst a #'2+ 'ID)))))))

(defun tfunc-defn-intro-type (a dtype defn)
  (if (dpi-p dtype)
      (dpi (dpi-dom dtype)
	   (tfunc-defn-intro-type (app (dbsubst a #'1+ 'ID) 0)
				  (dpi-cod dtype)
				  (gen-lam-body defn)))
    (dpi *pred*
	 (dpi (pf (app 0 (gen-pair-fst (dbsubst defn #'1+ 'ID))))
	      (pf (app 1 (gen-pair-fst (dbsubst a #'2+ 'ID))))))))

(defun reln-defn-intro-type (a dtype defn)
  (if (dpi-p dtype)
      (dpi (dpi-dom dtype)
	   (reln-defn-intro-type (app (dbsubst a #'1+ 'ID) 0)
				 (dpi-cod dtype)
				 (gen-lam-body defn)))
    (dpi (pf defn)
	 (pf (dbsubst a #'1+ 'ID)))))

(defun reln-defn-elim-type (a dtype defn)
  (if (dpi-p dtype)
      (dpi (dpi-dom dtype)
	   (reln-defn-elim-type (app (dbsubst a #'1+ 'ID) 0)
				(dpi-cod dtype)
				(gen-lam-body defn)))
    (dpi (pf a)
	 (pf (dbsubst defn #'1+ 'ID)))))

(defun leibniz-defn-term (dtype)
  (if (dpi-p dtype)
      (lam
       (leibniz-defn-term (dpi-cod dtype)))
    (lam (lam 0))))

(defun reln-defn-term (dtype)
  (if (dpi-p dtype)
      (lam
       (reln-defn-term (dpi-cod dtype)))
    (lam 0)))

(defun auto-gen-name (name suff &optional (val t))
  (let ((name2 (intern (format nil "~d#~d" name suff))))
    (when val
      (setf (get name2 'auto-gen) val))
    name2))

(defun auto-gen-abbrev-cong (a)
  (unless (dtype-returns-pf-p (get a 'dbtype))
    (let ((ac (auto-gen-name a "Cong" 'CONG)))
      (unless (abbrevname-p ac) ; already done
	(let ((d (congruence-abbrev-pf-term a (auto-gen-name a "Eq" nil))))
	  (if (claimname-p ac)
	      (claim2abbrev ac d (adjoin "Scunak" (get a 'authors) :test #'equal))
	    (newabbrev ac (congruence-pf-type (get a 'dbtype) a)
		       d (adjoin "Scunak" (get a 'authors) :test #'equal)))
	  (setf (get ac 'timestamp) (+ (get a 'timestamp) 0.3))
	  )))))

(defun auto-gen-claim-cong (a)
  (unless (dtype-returns-pf-p (get a 'dbtype))
    (let ((ac (auto-gen-name a "Cong" 'CONG)))
      (unless (or (abbrevname-p ac) (claimname-p ac)) ; already done
	(newclaim ac (congruence-pf-type (get a 'dbtype) a)
		  (adjoin "Scunak" (get a 'authors) :test #'equal))
	(setf (get ac 'timestamp) (+ (get a 'timestamp) 0.3))
	))))

(defun ensure-timestamp-before (name trm ts)
  (if (and (symbolp trm) (get name 'timestamp))
      (when (>= (get trm 'timestamp) ts)
	(fail (format nil "term for ~d uses ~d, which was given after the claim"
		      name trm) name trm ts))
    (cond ((lam-p trm) (ensure-timestamp-before name (lam-body trm) ts))
	  ((app-p trm)
	   (ensure-timestamp-before name (app-func trm) ts)
	   (ensure-timestamp-before name (app-arg trm) ts))
	  ((pair-p trm)
	   (ensure-timestamp-before name (pair-fst trm) ts)
	   (ensure-timestamp-before name (pair-snd trm) ts))
	  ((fst-p trm)
	   (ensure-timestamp-before name (fst-arg trm) ts))
	  ((snd-p trm)
	   (ensure-timestamp-before name (snd-arg trm) ts))
	  (t nil))))

(defun all-claims ()
  (let ((ret nil))
    (dolist (c *global-sigma*)
      (when (claimname-p c) (push c ret)))
    (remove-duplicates ret)))
