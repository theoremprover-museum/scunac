;   Scunak: A Mathematical Assistant System
;   Copyright (C) 2006 Chad E Brown (cebrown2323@yahoo.com)
;
;   This program is free software; you can redistribute it and/or modify
;   it under the terms of the GNU General Public License as published by
;   the Free Software Foundation; either version 2 of the License, or
;   (at your option) any later version.
;
;   This program is distributed in the hope that it will be useful,
;   but WITHOUT ANY WARRANTY; without even the implied warranty of
;   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;   GNU General Public License for more details.
;
;   You should have received a copy of the GNU General Public License along
;   with this program; if not, write to the Free Software Foundation, Inc.,
;   51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.

; Author: Chad E Brown
; October 2005
(setq input1-gcats '(CLABBNAME))

; Pseudo-Automath Set Theory syntax

; NORMAL : EXTRACT|(\NAMELIST.EXTRACT)|(\NAMELIST.<EXTRACT,EXTRACT>)|<EXTRACT,EXTRACT>
; EXTRACT : EXTRACT2|(EXTRACT2)
; EXTRACT2 : NAME|(NAME NORMALL)|
;    EXTRACT BINOP EXTRACT|~EXTRACT|
;    |exists NAMELIST:EXTRACT . EXTRACT|forall NAMELIST:EXTRACT . EXTRACT
;    |exists1 NAMELIST:EXTRACT . EXTRACT
;    |{NAME|EXTRACT}|{NAME:EXTRACT|EXTRACT}|{EXTRACTL}|{}
;    |{<<NAME,NAME>>:EXTRACT \times EXTRACT|EXTRACT}
;    |<<EXTRACT,EXTRACT>>
; EXTRACTL : EXTRACT|EXTRACT,EXTRACTL
; BINOP : !=|==|=>|<=>|&|\||::|;|\cup|\cap|\times
;         UBINOP
; UBINOP : @|@@|@NUM@|+|++|+NUM+|*|**|*NUM*|--|-NUM-|/|//|/NUM/|<|>|<=|=>|<NUM<|>NUM>|<NUM<=|=>NUM>|=NUM=|=!NUM=

; NAMELIST : NAME|NAME NAMELIST
; NORMALL : NORMAL|NORMAL NORMALL
; NAME's begin with alphabetic characters

(setq input1-grules
      '(
	(CONTEXT1 DOCUMENTITEM ("[" NAME ":" DTYPE1 "]")
		  #'(lambda (x dtp) (input1-newvar x dtp))
		  )
;	(CONTEXT1 DOCUMENTITEM ("[" NAME ":" "(" DTYPE1 ")]")
;		  #'(lambda (x dtp) (input1-newvar x dtp))
;		  )
	(CONST1 DOCUMENTITEM (NEWAPP ":" DTYPE2 ".")
		#'(lambda (x dtp) (input1-newconst x dtp))
		)
	(CONST2 DOCUMENTITEM (NEWAPP ":?" DTYPE2 ".")
		#'(lambda (x dtp) (input1-newconst x dtp t))
		)
	(CLAIM1 DOCUMENTITEM (NEWAPP ":" DTYPE2 "?")
		#'(lambda (x dtp) (input1-newclaim x dtp))
		)
	(CLAIM2 DOCUMENTITEM (NEWAPP ":?" DTYPE2 "?")
		#'(lambda (x dtp) (input1-newclaim x dtp t))
		)
	(ABBREV1 DOCUMENTITEM (NEWAPP ":" DTYPE2 WH "=" NORMAL ".")
		 #'(lambda (x dtp defn) (input1-newabbrev x dtp defn))
		 )
	(ABBREV2 DOCUMENTITEM (NEWAPP ":" DTYPE2 "=" NORMAL ".")
		 #'(lambda (x dtp defn) (input1-newabbrev x dtp defn))
		 )
	(ABBREV3 DOCUMENTITEM (NEWAPP "=" EXTRACT ".")
		 #'(lambda (x defn) (input1-newabbrev-extr x defn))
		 )
	(ABBREV3 DOCUMENTITEM (NEWAPP ":=" NORMAL ".")
		 #'(lambda (x defn) (input1-claim2abbrev x defn))
		 )
	(ABBREV1u DOCUMENTITEM (NEWAPP ":" DTYPE2 WH "=" NORMAL "?")
		 #'(lambda (x dtp defn) (input1-newabbrev x dtp defn t))
		 )
	(ABBREV2u DOCUMENTITEM (NEWAPP ":" DTYPE2 "=" NORMAL "?")
		 #'(lambda (x dtp defn) (input1-newabbrev x dtp defn t))
		 )
	(ABBREV3u DOCUMENTITEM (NEWAPP "=" EXTRACT "?")
		 #'(lambda (x defn) (input1-newabbrev-extr x defn t))
		 )

	(COERCION1 DOCUMENTITEM ("coercion" WH EXTRACT ".")
		   #'(lambda (pftrm0)
		       (create-input1-coercion pftrm0)))

	(NOTATIONINF DOCUMENTITEM ("notation" WH UBINOP WH EXTRACT ".")
		     #'(lambda (op defn)
			 (let ((fn (if (consp defn)
				       #'(lambda (x y)
					   (append defn (list x y)))
				     #'(lambda (x y)
					 (list defn x y)))))
			   (if (consp op)
			       (let* ((opv (car op))
				      (opval (eval opv))
				      (n (cadr op)))
				 (when (<= (length opval) n)
				   (setq opval (append opval (make-list (1+ (- n (length opval)))))))
				 (setf (nth n opval) fn)
				 (set opv opval))
			     (set op fn)))))
	(NOTATIONB DOCUMENTITEM ("notation" WH NAME WH EXTRACT ".")
		   #'(lambda (n defn)
		       (setf (get (intern n) 'notation) (if (consp defn) defn (list defn)))
		       t))

	(LOAD DOCUMENTITEM ("load" WH "\"" STRING "\"!")
	      #'(lambda (filename)
		  (record-input1-state)
		  (when (> *verbose* 1)
		    (format t "Loading ~d~%" filename))
		  (s-readinput1-real filename)))
	(LOADL DOCUMENTITEM ("loadl" WH "\"" STRING "\"!")
	      #'(lambda (filename)
		  (record-input1-state)
		  (setq filename (format nil "~d.lisp" filename))
		  (when (> *verbose* 1)
		    (format t "Loading Lisp ~d~%" filename))
		  (s-load filename)))
	(LING1 DOCUMENTITEM ("ling" WH NEWAPP WH GENGRAMCAT WH LINGRULE "!")
	       #'(lambda (newapp ggcat lrule)
		   (add-ling-gen-rule newapp ggcat lrule)))
	(AUTH1 DOCUMENTITEM ("author" WH "\"" STRING "\"!") ; do string
	       #'(lambda (str)
		   (set-authors (list str)))) ; write set-authors
	(AUTH2 DOCUMENTITEM ("authors" WH QSTRINGL "!") ; do stringl
	       #'(lambda (strl)
		   (set-authors strl)))

	(DIBE1 DOCUMENTITEM ("dibe" WH "[" EXTRACTL "]" "!")
	       #'(lambda (el)
		   (input1-dibe 0 el)))
	(DIBE2 DOCUMENTITEM ("dibe" WH SMALLNUM WH  "[" EXTRACTL "]" "!")
	       #'(lambda (i el)
		   (input1-dibe i el)))

;	(DIBE1 DOCUMENTITEM ("iprove!")
;	       (input1-iprove))

	(SCI1 SCI-ITEM ("[" NAME ":" DTYPE1 "]")
	      #'(lambda (x dtp) (sci-newvar x dtp))
	      )
	(SCI1 SCI-ITEM ("assume" WH DTYPE1 ".")
	      #'(lambda (dtp) (sci-assume dtp))
	      )
	(SCI2 SCI-ITEM ("check" WH EXTRACT ".") #'(lambda (x) (sci-check x)))
	(SCI3 SCI-ITEM ("q.") (SCI-QUIT-COMMAND))

	(LOAD TOP-ITEM ("load" WH "\"" STRING "\"")
	      #'(lambda (filename)
		  (record-input1-state)
		  (setq grammar input1-grammar)
		  (setq *linecomment-chars* '(#\%))
		  (when (> *verbose* 1)
		    (format t "Loading ~d~%" filename))
		  (s-readinput1-real filename)))
	(LOADL TOP-ITEM ("loadl" WH "\"" STRING "\"")
	      #'(lambda (filename)
		  (record-input1-state)
		  (setq filename (format nil "~d.lisp" filename))
		  (when (> *verbose* 1)
		    (format t "Loading Lisp ~d~%" filename))
		  (s-load filename)))
	(SCI3 TOP-ITEM ("lisp") (TOP-LISP-COMMAND))
	(SCI3 TOP-ITEM ("q.") (TOP-QUIT-COMMAND))
	(SCI3 TOP-ITEM ("q") (TOP-QUIT-COMMAND))
;	(SCI3 TOP-ITEM ("load" WH "\"" STRING "\"!")
;              #'(lambda (filename)
;		  (readinput1-real filename)))
;	(SCI3 TOP-ITEM ("loadl" WH "\"" STRING "\"!")
;              #'(lambda (filename)
;		  (load filename)))
	(SCI3 TOP-ITEM ("tutor" WH NEWAPP)
	      #'(lambda (c)
		  (setq *tutor-nl* nil)
		  (tutor-claim c)))
	(SCI3 TOP-ITEM ("tutor-auto-back" WH NAMELIST ".")
	      #'(lambda (nl)
		  (setq *tutor-auto-back* nil)
		  (dolist (n nl t)
		    (let ((c (intern n)))
		      (when (get c 'dbtype)
			(push c *tutor-auto-back*))))))
	(SCI3 TOP-ITEM ("tutor-student-usable" WH NAMELIST ".")
	      #'(lambda (nl)
		  (setq *sig-granularity-perfect* nil)
		  (dolist (n nl t)
		    (let ((c (intern n)))
		      (when (get c 'dbtype)
			(push c *sig-granularity-perfect*))))))
	(SCI3 TOP-ITEM ("tutor-only-usable" WH NAMELIST ".")
	      #'(lambda (nl)
		  (setq *sig-granularity-toohigh* nil)
		  (dolist (n nl t)
		    (let ((c (intern n)))
		      (when (get c 'dbtype)
			(push c *sig-granularity-toohigh*))))))
	(SCI3 TOP-ITEM ("nltutor" WH NEWAPP)
	      #'(lambda (c)
		  (setq *tutor-nl* t)
		  (tutor-claim c)))
	(SCI3 TOP-ITEM ("proofread" WH "\"" STRING "\"" WH NEWAPP ".")
	      #'(lambda (filename newapp)
		  (proofread filename newapp)))
	(DITOP TOP-ITEM (DOCUMENTITEM) #'(lambda (x)
					   (unless x
					     (format t "WARNING: I'm afraid there seems to have been some sort of problem.~%I doubt your command was successful.~%"))))
	(DI TOP-ITEM ("help")
	    (print-help-top))
	(DI TOP-ITEM ("help" WH NAME) #'(lambda (x) (print-help-name (intern x))))
	(SCI3 TOP-ITEM ("vampire" WH NAME) 
	      #'(lambda (xs)
		  (let* ((x (intern xs))
			 (ts (get x 'timestamp)))
		    (if (and (claimname-p x) ts)
			(if (dtype-returns-pf-p (get x 'dbtype))
			    (if (vampire-res-fill-claim x
							(remove-if-not #'(lambda (z)
									   (< (get z 'timestamp) ts))
								       *global-sigma*))
				(format t "*Vampire found a refutation!*~%")
			      (format t "Vampire did not find a refutation.~%"))
			  (format t "~d does not have a proof type.~%" x))
		      (format t "~d is not an open claim.~%" x)))))
	(EXT TOP-ITEM ("input-sig-agent" WH "\"" STRING "\"" WH "\"" STRING "\"")
	     #'(lambda (mach port)
		 (input-sig-agent
		  mach
		  (read-from-string port))
		 t))
	(EXT TOP-ITEM ("input-sig-agent" WH "\"" STRING "\"" WH "\"" STRING "\"" WH "\"" STRING "\"")
	     #'(lambda (mach port info)
		 (input-sig-agent
		  mach
		  (read-from-string port)
		  info)
		 t))
	(EXT TOP-ITEM ("output-sig-agent" WH "\"" STRING "\"" WH "\"" STRING "\".")
	     #'(lambda (mach port)
		 (output-sig-agent
		  mach
		  (read-from-string port))
		 t))
	(EXT TOP-ITEM ("output-sig-agent" WH "\"" STRING "\"" WH "\"" STRING "\"" WH "\"" STRING "\".")
	     #'(lambda (mach port info)
		 (output-sig-agent
		  mach
		  (read-from-string port)
		  (read-from-string info))
		 t))
	(EXT TOP-ITEM ("output-sig-agent" WH "\"" STRING "\"" WH "\"" STRING "\"" WH "\"" STRING "\"" WH "\"" STRING "\".")
	     #'(lambda (mach port info beg)
		 (output-sig-agent
		  mach
		  (read-from-string port)
		  (read-from-string info)
		  (read-from-string beg)
		  )
		 t))
	(EXT TOP-ITEM ("output-sig-agent" WH "\"" STRING "\"" WH "\"" STRING "\"" WH "\"" STRING "\"" WH "\"" STRING "\"" WH "\"" STRING "\".")
	     #'(lambda (mach port info beg end)
		 (output-sig-agent
		  mach
		  (read-from-string port)
		  info
		  (read-from-string beg)
		  (read-from-string end))
		 t))
	(EXT TOP-ITEM ("remove-fill-gap-agent" WH NAME)
	     #'(lambda (name)
		 (remove-external-fill-gap-agent
		  (if (stringp name) (intern name) name))
		 t))
	(EXT TOP-ITEM ("add-fill-gap-agent" WH NAME WH "\"" STRING "\"" WH "\"" STRING "\"")
	     #'(lambda (name mach port)
		 (add-external-fill-gap-agent
		  (if (stringp name) (intern name) name)
		  mach
		  (read-from-string port))
		 t))
	(EXT TOP-ITEM ("add-fill-gap-agent-usable" WH NAME WH "\"" STRING "\"" WH "\"" STRING "\"")
	     #'(lambda (name mach port)
		 (add-external-fill-gap-agent-usable
		  (if (stringp name) (intern name) name)
		  mach
		  (read-from-string port))
		 t))
	(SCI3 TOP-ITEM ("otter" WH NAME) 
	      #'(lambda (xs)
		  (let* ((x (intern xs))
			 (ts (get x 'timestamp)))
		    (if (and (claimname-p x) ts)
			(if (dtype-returns-pf-p (get x 'dbtype))
			    (if (otter-res-fill-claim x
						      (remove-if-not #'(lambda (z)
									 (< (get z 'timestamp) ts))
								     *global-sigma*))
				(format t "*Otter found a refutation!*~%")
			      (format t "Otter did not find a refutation.~%"))
			  (format t "~d does not have a proof type.~%" x))
		      (format t "~d is not an open claim.~%" x)))))
	(SCI3 TOP-ITEM ("tps" WH NAME) 
	      #'(lambda (xs)
		  (let* ((x (intern xs))
			 (ts (get x 'timestamp)))
		    (if (and (claimname-p x) ts)
			(if (dtype-returns-pf-p (get x 'dbtype))
			    (if (tps-res-fill-claim x)
				(format t "*TPS found a proof!*~%")
			      (format t "TPS did not find a proof.~%"))
			  (format t "~d does not have a proof type.~%" x))
		      (format t "~d is not an open claim.~%" x)))))
	(TOP1 TOP-ITEM ("prove" WH NAME)
	      #'(lambda (xs)
		  (let* ((x (intern xs))
			 (ts (get x 'timestamp)))
		    (if (and (claimname-p x) ts)
			(if (dtype-returns-pf-p (get x 'dbtype))
			    (scip x)
			  (format t "~d does not have a proof type.~%" x))
		      (format t "~d is not an open claim.~%" x)))))
	(TOP1 TOP-ITEM ("all-claims")
	      (let ((cl (all-claims)))
		(if cl
		    (if (cdr cl)
			(progn
			  (format t "Open Claims:~%")
			  (dolist (c cl)
			    (format t "~d~%" c)))
		      (format t "Open Claim: ~d~%" (car cl)))
		  (format t "There Are No Open Claims.~%"))))

	(SCI3 TOP-ITEM ("show-ctx")
	      (progn
		(if *input1-ctx-info*
		    (dolist (xi *input1-ctx-info*)
		      (format t "~d:~d~%"
			      (car xi)
			      (output1-type-string (cadar (cadr xi)))))
		  (format t "Empty Ctx~%")
		  )))
	(SCI3 TOP-ITEM ("clear-ctx")
	      (progn
		(clear-bvars (mapcar #'car *input1-ctx-info*))
		(setq *input1-ctx-info* nil)
		(format t "Empty Ctx~%")
		))
	(SCI3 TOP-ITEM ("push-ctx")
	      (progn
		(push-input1-ctx)
		))
	(SCI3 TOP-ITEM ("pop-ctx")
	      (progn
		(if *input1-ctx-stack*
		    (progn
		      (pop-input1-ctx)
		      (if *input1-ctx-info*
			  (format t "Most Recent In Ctx:~%~d:~d~%"
				  (caar *input1-ctx-info*)
				  (output1-type-string (cadar (cadar *input1-ctx-info*))))
			(format t "Empty Ctx~%")))
		  (format t "No previous ctx~%"))))
	(SCU1 TOP-ITEM ("typeof" WH EXTRACT)
	      #'(lambda (pre-ex)
		  (multiple-value-bind
		   (e newtp info fail)
		   (extr-fill-in-blanks-1 pre-ex *input1-state* (input1-blanks-prefix *input1-ctx-info*))
		   (if (or info fail)
		       (progn
			 (format t "Could not determine a well-typed extraction term from input.~%")
			 (when fail
			   (format t "~d~%" fail))
			 (dolist (z info)
			   (when (eq (car z) 'EVAR) 
			     (let ((trm (nth 4 z))
				   (dtp (nth 5 z))
				   (etp (nth 6 z)))
			       (if (and trm dtp etp)
				   (format t "Term: ~d~%Has Type: ~d~%Expected Type: ~d~%"
					   (output1-extraction-string trm nil t)
					   (output1-type-string etp nil t)
					   (output1-type-string dtp nil t))
				 (when (nth 3 z)
				   (format t "~d" (nth 3 z))))))))
		     (if e
			 (format t "Type: ~d~%" (output1-type-string newtp (mapcar #'car *input1-ctx-info*)))
		       (format t "Could not determine an extraction term from input.~%"))))))

	(SCU1 TOP-ITEM ("justify" WH EXTRACT)
	      #'(lambda (pre-ex)
		  (multiple-value-bind
		   (e newtp info fail)
		   (extr-fill-in-blanks-1 pre-ex *input1-state* (input1-blanks-prefix *input1-ctx-info*))
		   (if (or info fail)
		       (progn
			 (format t "Could not determine a well-typed extraction term from input.~%")
			 (when fail
			   (format t "~d~%" fail))
			 (dolist (z info)
			   (when (eq (car z) 'EVAR) 
			     (let ((trm (nth 4 z))
				   (dtp (nth 5 z))
				   (etp (nth 6 z)))
			       (if (and trm dtp etp)
				   (format t "Term: ~d~%Has Type: ~d~%Expected Type: ~d~%"
					   (output1-extraction-string trm nil t)
					   (output1-type-string etp nil t)
					   (output1-type-string dtp nil t))
				 (when (nth 3 z)
				   (format t "~d" (nth 3 z))))))))
		     (if (heq newtp (prop))
			 (let* ((goaltp (pf (named-term-to-db-1 (mapcar #'car *input1-ctx-info*) e)))
				(g (quick-fill-gap (db-ctx-info *input1-ctx-info*)
						   goaltp *justify-usable* t 0 nil)))
			   (if g
			       (format t "Proof Term:~%~d~%" (output1-extraction-string 
							      (normalize (app-n-1-to-0 (length *input1-ctx-info*) (caar g)))
							      (mapcar #'car *input1-ctx-info*)
							      t))
			     (format t "Could not justify prop~%")))
		       (format t "Given extraction was not a prop~%"))))))

	(SCU1 TOP-ITEM ("use" WH NAMELIST)
	      #'(lambda (xl)
		  (setq xl (mapcar #'(lambda (x)
				       (if (stringp x) (intern x) x)) xl))
		  (if (member '|all| xl)
		      (setq *justify-usable* *global-sigma*)
		    (if (member '|none| xl)
			(setq *justify-usable* nil)
		    (progn
		      (setq *justify-usable* nil)
		      (dolist (x xl)
			(cond ((eq x '|fo|)
			       (setq *justify-usable*
				     (union (remove-if-not #'(lambda (co)
							       (and (not (get co 'auto-gen)) (or (get co 'fo-unif-type) (get co 'fo-type))))
							   *global-sigma*)
					    *justify-usable*)))
			      ((eq x '|defns|)
			       (setq *justify-usable*
				     (union (remove-if-not #'(lambda (co)
							       (get co 'auto-gen))
							   *global-sigma*)
					    *justify-usable*)))
			      ((eq x '|so|)
			       (setq *justify-usable*
				     (union (remove-if #'(lambda (co)
							   (or (get co 'auto-gen) (get co 'fo-unif-type) (get co 'fo-type)))
						       *global-sigma*)
					    *justify-usable*)))
			      ((and (get x 'dbtype) (or (dtype-returns-dclass-p (get x 'dbtype))
							(dtype-returns-pf-p (get x 'dbtype))))
			       (push x *justify-usable*)
			       )
			      (t (format t "Ignoring ~d~%" x)))))))
		  (if *justify-usable*
		      (format t "Reset usable~%")
		    (format t "WARNING: usable empty!~%"))))

	(SCU1 TOP-ITEM ("unif+")
	      (progn
		  (format t "~d~%" (incf *preunify-msv-goal*))
		  (format t "~d~%" (incf *preunify-msv-hence*))
		  (format t "~d~%" (incf *preunify-msv-supp*))))
	(SCU1 TOP-ITEM ("unif-")
	      (progn
		  (format t "~d~%" (decf *preunify-msv-goal*))
		  (format t "~d~%" (decf *preunify-msv-hence*))
		  (format t "~d~%" (decf *preunify-msv-supp*))))
						 
		      
		  

;	(LR1 LINGRULE ("(@" WH LINGRULEL ")") 
;	     #'(lambda (l) (apply #'@ l)))
;	(LR2 LINGRULE ("\"" LINGSTRING "\"") ?)
;	(LR3 LINGRULE (LINGRULE "::" ?) ?)

	(GGCP GENGRAMCAT ("PROOF") PROOF)
	(GGCMO GENGRAMCAT ("MATHOBJ") MATHOBJ)
	(GGCO GENGRAMCAT ("OBJ") OBJ)
	(GGCMP GENGRAMCAT ("MATHPROP") MATHPROP)
	(GGCP GENGRAMCAT ("PROP") PROP)
	(GGCA GENGRAMCAT ("ASSERTION") ASSERTION)
	(GGCD GENGRAMCAT ("DISCOURSE") DISCOURSE)

	(COMM1 COMMAND ("q.") (QUIT-COMMAND))
	(COMM2 COMMAND ("prove" WH EXTRACT ".") 
	       #'(lambda (x) (prove-command x)))
	(COMM3 COMMAND ("let" WH NAME ".")
	       #'(lambda (x) (let-command x)))
	(COMM4 COMMAND ("let" WH NAME ":" DTYPE0 ".")
	       #'(lambda (x y) (let-command x y)))
	(COMM5 COMMAND ("assume" WH EXTRACT ".")
	       #'(lambda (x) (assume-command x)))
	(COMM4 COMMAND ("let" WH NAME ":" DTYPE0)
	       #'(lambda (x y) (let-command x y)))
	(COMM5 COMMAND ("assume" WH EXTRACT)
	       #'(lambda (x) (assume-command x)))

	(COMMSTAT COMMAND ("status.") (print-status))
	(PCOMMSTAT PFCOMMAND ("status.") '(print-status))

	(PCOMMSTAT PFCOMMAND ("help") '(print-tutor-help))
	(PCOMMSTAT PFCOMMAND ("help.") '(print-tutor-help))

	(PCOMM1 PFCOMMAND ("qed") '(QED-PFCOMMAND))
	(PCOMM1 PFCOMMAND ("done") '(QED-PFCOMMAND))
	(PCOMM1 PFCOMMAND ("qed.") '(QED-PFCOMMAND))
	(PCOMM1 PFCOMMAND ("done.") '(QED-PFCOMMAND))
	(PCOMM1 PFCOMMAND ("undo.") '(UNDO-PFCOMMAND))
	(PCOMM1 PFCOMMAND ("undo") '(UNDO-PFCOMMAND))
	(PCOMM2 PFCOMMAND ("i" WH "give" WH "up") '(QUIT-PFCOMMAND))
	(PCOMM2 PFCOMMAND ("i" WH "give" WH "up.") '(QUIT-PFCOMMAND))
	(PCOMM3 PFCOMMAND ("claim" WH EXTRACT)
	       #'(lambda (x) (list 'claim-pfcommand x)))
	(PCOMM3 PFCOMMAND ("claim" WH EXTRACT ".")
	       #'(lambda (x) (list 'claim-pfcommand x)))
	(PCOMM3 PFCOMMAND ("let" WH NAMELIST ".")
	       #'(lambda (xl) (list 'let-pfcommand (mapcar #'intern xl))))
	(PCOMM4 PFCOMMAND ("let" WH NAMELIST ":" DTYPE0 ".")
	       #'(lambda (xl y) (list 'let-pfcommand (mapcar #'intern xl) y)))
	(PCOMM4 PFCOMMAND ("let" WH NAMELIST ":" DTYPE0)
	       #'(lambda (xl y) (list 'let-pfcommand (mapcar #'intern xl) y)))
	(PCOMM5 PFCOMMAND ("assume" WH EXTRACT ".")
	       #'(lambda (x) (list 'assume-pfcommand x)))
	(PCOMM5 PFCOMMAND ("assume" WH EXTRACT)
	       #'(lambda (x) (list 'assume-pfcommand x)))
	(PCOMM2 PFCOMMAND ("willshow" WH EXTRACT ".") 
	       #'(lambda (x) (list 'subgoal-pfcommand x)))
	(PCOMM2 PFCOMMAND ("willshow" WH EXTRACT) 
	       #'(lambda (x) (list 'subgoal-pfcommand x)))
;	(PCOMM7 PFCOMMAND ("exists" WH NAME ".") #'(lambda (x) (list 'EXISTS-PFCOMMAND x)))
;	(PCOMM7 PFCOMMAND ("exists" WH NAME WH EXTRACT ".") #'(lambda (x y) (list 'EXISTS-PFCOMMAND x nil y)))
	(PCOMM7 PFCOMMAND ("exists" WH NAME ":" EXTRACT WH "." WH EXTRACT ".") #'(lambda (x y z) (list 'EXISTS-PFCOMMAND x y z)))
	(PCOMM6 PFCOMMAND ("cases.") '(CASES-PFCOMMAND))
	(PCOMM7 PFCOMMAND ("cases" WH EXTRACT ".") #'(lambda (x) (list 'CASES-PFCOMMAND x)))
	(PCOMM8 PFCOMMAND ("contradiction.") (list 'CONTRADICTION-PFCOMMAND))
	(PCOMM9 PFCOMMAND ("case" WH SMALLNUM ".") #'(lambda (i) (list 'CASE-PFCOMMAND i)))
	(PCOMM10 PFCOMMAND ("case" WH SMALLNUM WH EXTRACT ".") #'(lambda (i x) (list 'CASE-PFCOMMAND i x)))
	(PCOMM11 PFCOMMAND ("close" WH "case.") '(CLOSE-CASE-PFCOMMAND))
	(PCOMM12 PFCOMMAND ("hence" WH EXTRACT ".") #'(lambda (x) (list 'HENCE-PFCOMMAND x)))
	(PCOMM13 PFCOMMAND ("clearly" WH EXTRACT ".") #'(lambda (x) (list 'CLEARLY-PFCOMMAND x)))
	(PCOMM12 PFCOMMAND ("hence" WH EXTRACT) #'(lambda (x) (list 'HENCE-PFCOMMAND x)))
	(PCOMM13 PFCOMMAND ("clearly" WH EXTRACT) #'(lambda (x) (list 'CLEARLY-PFCOMMAND x)))
	(PCOMM14 PFCOMMAND ("by" WH EXTRACTL "," WH "we" WH "have" WH EXTRACT ".")
		 #'(lambda (refs x) (list 'BY-PFCOMMAND refs x)))
	(PCOMM14 PFCOMMAND ("since" WH EXTRACTL "," WH "we" WH "have" WH EXTRACT ".")
		 #'(lambda (pre-conds x) (list 'SINCE-PFCOMMAND pre-conds x)))
	(PCOMM15 PFCOMMAND ("alts" WH PFCOMMANDL ".") ; this doesn't yet work
		 #'(lambda (pcl) (list 'alt-pfcommands pcl)))

	(PCOMML1 PFCOMMANDL ("[" PFCOMMAND "]") #'list)
	(PCOMML2 PFCOMMANDL ("[" PFCOMMAND "]" WH PFCOMMANDL) #'cons)
	(EL1 EXTRACTL (EXTRACT) #'list)
	(EL2 EXTRACTL (EXTRACT "," WH EXTRACTL) #'cons)
	(EL2 EXTRACTL (EXTRACT "," EXTRACTL) #'cons)
	(SN1 SMALLNUM ("1") 1)
	(SN2 SMALLNUM ("2") 2)
	(SN3 SMALLNUM ("3") 3)
	(SN4 SMALLNUM ("4") 4)
	(SN5 SMALLNUM ("5") 5)
	(SN6 SMALLNUM ("6") 6)
	(SN7 SMALLNUM ("7") 7)
	(SN8 SMALLNUM ("8") 8)
	(SN9 SMALLNUM ("9") 9)

	(DTYPE2A DTYPE2 (DTYPE1)
		 #'identity
		 )
	(DTYPE2B DTYPE2 ("{" NAME ":" DTYPE1 "}" DTYPE2)
		 #'(lambda (x domtp codtp)
		     (cons 'dpi (cons (intern x) (cons domtp codtp)))))
;	(DTYPE2B DTYPE2 ("({" NAME ":" DTYPE1 "}" DTYPE2 ")")
;		 #'(lambda (x domtp codtp)
;		     (cons 'dpi (cons (intern x) (cons domtp codtp)))))
	(DTYPE2Bw DTYPE2 ("{" NAME ":" DTYPE1 "}" WH DTYPE2)
		 #'(lambda (x domtp codtp)
		     (cons 'dpi (cons (intern x) (cons domtp codtp)))))
	(DTYPE2C DTYPE2 (DTYPE1 "->" DTYPE2)
		 #'(lambda (domtp codtp)
		     (cons 'darr (cons domtp codtp))))
;	(DTYPE2C DTYPE2 ("(" DTYPE1 "->" DTYPE2 ")")
;		 #'(lambda (domtp codtp)
;		     (cons 'darr (cons domtp codtp))))
	(DTYPE2Cwn DTYPE2 (DTYPE1 WH "->" DTYPE2)
		 #'(lambda (domtp codtp)
		     (cons 'darr (cons domtp codtp))))
	(DTYPE2Cnw DTYPE2 (DTYPE1 "->" WH DTYPE2)
		 #'(lambda (domtp codtp)
		     (cons 'darr (cons domtp codtp))))
	(DTYPE2Cww DTYPE2 (DTYPE1 WH "->" WH DTYPE2)
		 #'(lambda (domtp codtp)
		     (cons 'darr (cons domtp codtp))))
	(DTYPE2Cp DTYPE2 ("(" DTYPE1 ")" "->" DTYPE2)
		  #'(lambda (domtp codtp)
		      (cons 'darr (cons domtp codtp))))
	(DTYPE2Cpr DTYPE2 (DTYPE1 "->" "(" DTYPE2 ")")
		  #'(lambda (domtp codtp)
		      (cons 'darr (cons domtp codtp))))
	(DTYPE2Cpwn DTYPE2 ("(" DTYPE1 ")" WH "->" DTYPE2)
		 #'(lambda (domtp codtp)
		     (cons 'darr (cons domtp codtp))))
	(DTYPE2Cpnw DTYPE2 ("(" DTYPE1 ")" "->" WH DTYPE2)
		 #'(lambda (domtp codtp)
		     (cons 'darr (cons domtp codtp))))
	(DTYPE2Cpww DTYPE2 ("(" DTYPE1 ")" WH "->" WH DTYPE2)
		 #'(lambda (domtp codtp)
		     (cons 'darr (cons domtp codtp))))
	(DTYPE1A DTYPE1 (DTYPE0)
		 #'identity
		 )
	(DTYPE1B DTYPE1 ("{" NAME ":" DTYPE0 "}" DTYPE1)
		 #'(lambda (x domtp codtp)
		     (cons 'dpi (cons (intern x) (cons domtp codtp)))))
;	(DTYPE1B DTYPE1 ("({" NAME ":" DTYPE0 "}" DTYPE1 ")")
;		 #'(lambda (x domtp codtp)
;		     (cons 'dpi (cons (intern x) (cons domtp codtp)))))
	(DTYPE1Bw DTYPE1 ("{" NAME ":" DTYPE0 "}" WH DTYPE1)
		 #'(lambda (x domtp codtp)
		     (cons 'dpi (cons (intern x) (cons domtp codtp)))))
	(DTYPE1C DTYPE1 (DTYPE0 "->" DTYPE1)
		 #'(lambda (domtp codtp)
		     (cons 'darr (cons domtp codtp))))
;	(DTYPE1C DTYPE1 ("(" DTYPE0 "->" DTYPE1 ")")
;		 #'(lambda (domtp codtp)
;		     (cons 'darr (cons domtp codtp))))
	(DTYPE1Cwn DTYPE1 (DTYPE0 WH "->" DTYPE1)
		 #'(lambda (domtp codtp)
		     (cons 'darr (cons domtp codtp))))
	(DTYPE1Cnw DTYPE1 (DTYPE0 "->" WH DTYPE1)
		   #'(lambda (domtp codtp)
		       (cons 'darr (cons domtp codtp))))
	(DTYPE1Cww DTYPE1 (DTYPE0 WH "->" WH DTYPE1)
		 #'(lambda (domtp codtp)
		     (cons 'darr (cons domtp codtp))))
	(DTYPE0A DTYPE0 ("prop") 'PROP)
	(DTYPE0B DTYPE0 ("obj") 'OBJ)
	(DTYPE0B DTYPE0 ("set") 'OBJ)
	(DTYPE0C DTYPE0 ("|-" WH EXTRACT)
		 #'(lambda (prop) (cons 'PF prop)))
	(DTYPE0C DTYPE0 (EXTRACT) ; preterms code tries to make this a type, class or pf
		 #'(lambda (pred) pred))
;	(DTYPE0D DTYPE0 (EXTRACT) ; default to turning prop to pf type
;		 #'(lambda (prop) (list 'PF prop)))

	(EXTR1 EXTRACT (EXTRACT2) #'identity)
	(EXTRP EXTRACT ("(" EXTRACT2 ")") #'identity)

	(EXTR1 EXTRACT2 (NAME) #'(lambda (x)
				   (let ((xx (intern x)))
				     (if (get xx 'notation)
					 (get xx 'notation)
				       xx))))
	(EXTR2 EXTRACT2 (NAME WH NORMALL) #'(lambda (x y)
					      (let ((xx (intern x)))
						(if (get xx 'notation)
						    (append (get xx 'notation) y)
						  (cons xx y)))))

	(BOP1 BINOP ("!=") #'(lambda (x y) (list '|not| (list '|eq| x y))))
	(BOP1 BINOP ("==") '|eq|)
	(BOP1 BINOP ("=>") '|imp|)
	(BOP1 BINOP ("<=>") '|equiv|)
	(BOP1 BINOP ("&") '|and|)
	(BOP1 BINOP ("|") '|or|)
	(BOP1 BINOP ("::") '|in|)
	(BOP1 BINOP ("<=") '|subset|) ; can be redefined by user now, subset default
	(BOP1 BINOP (";") '|setadjoin|)
	(BOP1 BINOP ("\\cup") '|binunion|)
	(BOP1 BINOP ("\\cap") '|binintersect|)
	(BOP1 BINOP ("\\times") '|cartprod|)

	(BOP1 UBINOP ("@") '*infix-at-op*)
	(BOP1 UBINOP ("@@") '*infix-at2-op*)
	(BOP1 UBINOP ("+") '*infix-plus-op*)
	(BOP1 UBINOP ("++") '*infix-plus2-op*)
	(BOP1 UBINOP ("*") '*infix-star-op*)
	(BOP1 UBINOP ("**") '*infix-star2-op*)
	(BOP1 UBINOP ("-") '*infix-minus-op*)
	(BOP1 UBINOP ("--") '*infix-minus2-op*)
	(BOP1 UBINOP ("/") '*infix-slash-op*)
	(BOP1 UBINOP ("//") '*infix-slash2-op*)
	(BOP1 UBINOP ("<") '*infix-less-op*)
	(BOP1 UBINOP (">") '*infix-greater-op*)
	(BOP1 UBINOP ("\\leq") '*infix-less-op*)
	(BOP1 UBINOP ("\\geq") '*infix-greater-op*)

	(EXTRBOP EXTRACT2 (EXTRACT BINOP EXTRACT)
		 #'(lambda (x bop y)
		     (if (symbolp bop)
			 (if (eq bop '|in|) ; special case; reversed
			     (list bop y x)
			   (list bop x y))
		       (funcall bop x y))))
	(EXTRBOP EXTRACT2 (EXTRACT WH BINOP WH EXTRACT)
		 #'(lambda (x bop y)
		     (if (symbolp bop)
			 (if (eq bop '|in|) ; special case; reversed
			     (list bop y x)
			   (list bop x y))
		       (funcall bop x y))))
	(EXTRBOP EXTRACT2 (EXTRACT WH UBINOP WH EXTRACT) ; force whitespace for ubinop's
		 #'(lambda (x ubop y)
		     (let ((f (eval ubop)))
		       (if f
			   (if (symbolp f)
			       (list f x y)
			     (funcall f x y))
			 nil))))
	(EXTRNOT EXTRACT2 ("~" EXTRACT)
		 #'(lambda (x)
		     (list '|not| x)))
	(EXTREX EXTRACT2 ("exists1" WH NAMELIST ":" EXTRACT WH "." WH EXTRACT)
		#'(lambda (nl bd body)
		    (dolist (n (reverse nl))
		      (setq body (list '|ex1| bd (cons 'LAM (cons (list (intern n)) body)))))
		    body))
	(EXTREX EXTRACT2 ("exists" WH NAMELIST ":" EXTRACT WH "." WH EXTRACT)
		#'(lambda (nl bd body)
		    (dolist (n (reverse nl))
		      (setq body (list '|dex| bd (cons 'LAM (cons (list (intern n)) body)))))
		    body))
	(EXTRALL EXTRACT2 ("forall" WH NAMELIST ":" EXTRACT WH "." WH EXTRACT)
		#'(lambda (nl bd body)
		    (dolist (n (reverse nl))
		      (setq body (list '|dall| bd (cons 'LAM (cons (list (intern n)) body)))))
		    body))
;	(EXTREX EXTRACT2 ("exists1" WH NAMELIST WH "." WH EXTRACT)
;		#'(lambda (nl body)
;		    (dolist (n (reverse nl))
;		      (setq body (list '|uex1| (cons 'LAM (cons (list (intern n)) body)))))
;		    body))
;	(EXTREX EXTRACT2 ("exists" WH NAMELIST WH "." WH EXTRACT)
;		#'(lambda (nl body)
;		    (dolist (n (reverse nl))
;		      (setq body (list '|ex| (cons 'LAM (cons (list (intern n)) body)))))
;		    body))
;	(EXTRALL EXTRACT2 ("forall" WH NAMELIST WH "." WH EXTRACT)
;		#'(lambda (nl body)
;		    (dolist (n (reverse nl))
;		      (setq body (list '|all| (cons 'LAM (cons (list (intern n)) body)))))
;		    body))
	(EXTRKP EXTRACT2 ("<<" EXTRACT "," EXTRACTL ">>")
		#'(lambda (x y)
		    (let ((ret x))
		      (do ((yl y (cdr yl)))
			  ((null (cdr yl))
			   (list '|kpair| ret (car yl)))
			  (setq ret (list '|kpair| ret (car yl)))))))

	(NORMALL2 NORMALL (NORMAL WH NORMALL) #'cons)
	(NORMALL1 NORMALL (NORMAL) #'list)

	(EXTRACTUND1 EXTRACT ("_") '_)
	(EXTRACTUND2 EXTRACT ("?") '?)
	(SETEXTR EXTRACT ("{" NAME "|" EXTRACT "}")
		 #'(lambda (x y) (list '_CLASSCONSTRUCTOR x y)))
	(SETEXTR EXTRACT ("{" NAME ":" EXTRACT "|" EXTRACT "}")
		 #'(lambda (x y z) (list '_SETCONSTRUCTOR x y z)))
	(PSETEXTR EXTRACT ("{<<" NAME "," NAME ">>:" EXTRACT WH "\\times" WH EXTRACT "|" EXTRACT "}")
		  #'(lambda (x y set1 set2 body) (list '_PAIRSETCONSTRUCTOR x y set1 set2 body)))
	(PSETEXTR EXTRACT ("{<<" NAME "," NAME ">>:(" EXTRACT WH "\\times" WH EXTRACT ")|" EXTRACT "}")
		  #'(lambda (x y set1 set2 body) (list '_PAIRSETCONSTRUCTOR x y set1 set2 body)))
	(SETENUM EXTRACT ("{" EXTRACTL "}")
		 #'(lambda (x) (cons '_SETENUM x)))
	(SETENUM EXTRACT ("{}") '|emptyset|)

	(NORMAL1 NORMAL (EXTRACT) #'identity)
	(NORMAL2 NORMAL ("(\\" NAMELIST "." EXTRACT ")") 
		 #'(lambda (lams extr)
		     (cons 'LAM (cons (mapcar #'intern lams) extr))))
	(NORMAL2p NORMAL ("(\\" NAMELIST ".<" EXTRACT "," EXTRACT ">)") 
		 #'(lambda (lams extr1 extr2)
		     (cons 'LAM (cons (mapcar #'intern lams) (cons 'PAIR (cons extr1 extr2))))))
;	(NORMAL3 NORMAL ("(\\" NAMELIST "." NAME WH NORMALL ")") 
;		 #'(lambda (lams f args)
;		     (cons 'LAM (cons (mapcar #'intern lams) (cons (intern f) args)))))
;	(NORMAL4 NORMAL ("<" EXTRACT "," NAME ">")
;		 #'(lambda (x y) (cons 'PAIR (cons x (list (intern y)))))) ; only pairs of atomic type, hence extraction.
;	(NORMAL5 NORMAL ("<" EXTRACT "," NAME WH NORMALL ">")
;		 #'(lambda (x y z) (cons 'PAIR (cons x (cons (intern y) z))))) ; only pairs of atomic type, hence extraction.
	(NORMAL6 NORMAL ("<" EXTRACT "," EXTRACT ">")
		 #'(lambda (x y) (cons 'PAIR (cons x y)))) ; only pairs of atomic type, hence extraction.
	
	(NA1 NEWAPP (NAME) #'(lambda (x)
				 (list (intern x))))
	(NA2 NEWAPP ("(" NAME WH NAMELIST ")") #'(lambda (x y)
						   (cons (intern x)
							 (mapcar #'intern
								 y))))

	(NL1 NAMELIST (NAME) #'list)
	(NL2 NAMELIST (NAME WH NAMELIST) #'cons)

;	(NL1 NAMECLIST (NAME) #'list)
;	(NL2 NAMECLIST (NAME "," NAMECLIST) #'cons)
;	(NL3 NAMECLIST (NAME "," WH NAMECLIST) #'cons)

	(NAME1 NAME (NAMEBEGCHAR NAMEREST) #'(lambda (x y) (format nil "~d~d" x y)))

	(NAMERnil NAMEREST nil "")
	(NAMERcons NAMEREST (NAMECHAR NAMEREST) #'(lambda (x y) (format nil "~d~d" x y)))

	(NUM1 NUMBER (DIGIT) #'identity)
	(NUM2 NUMBER (NUMBER DIGIT) #'(lambda (x y) (+ (* 10 x) y)))
	(DIGIT0 DIGIT ("0") 0)
	(DIGIT1 DIGIT ("1") 1)
	(DIGIT2 DIGIT ("2") 2)
	(DIGIT3 DIGIT ("3") 3)
	(DIGIT4 DIGIT ("4") 4)
	(DIGIT5 DIGIT ("5") 5)
	(DIGIT6 DIGIT ("6") 6)
	(DIGIT7 DIGIT ("7") 7)
	(DIGIT8 DIGIT ("8") 8)
	(DIGIT9 DIGIT ("9") 9)

	(NAMECHAR45 NAMECHAR ("-") #\-)
	(NAMECHAR43 NAMECHAR ("+") #\+)
	(NAMECHAR47 NAMECHAR ("/") #\/)
	(NAMECHAR48 NAMECHAR ("0") #\0)
	(NAMECHAR49 NAMECHAR ("1") #\1)
	(NAMECHAR50 NAMECHAR ("2") #\2)
	(NAMECHAR51 NAMECHAR ("3") #\3)
	(NAMECHAR52 NAMECHAR ("4") #\4)
	(NAMECHAR53 NAMECHAR ("5") #\5)
	(NAMECHAR54 NAMECHAR ("6") #\6)
	(NAMECHAR55 NAMECHAR ("7") #\7)
	(NAMECHAR56 NAMECHAR ("8") #\8)
	(NAMECHAR57 NAMECHAR ("9") #\9)
	(NAMECHAR65 NAMECHAR ("A") #\A)
	(NAMECHAR66 NAMECHAR ("B") #\B)
	(NAMECHAR67 NAMECHAR ("C") #\C)
	(NAMECHAR68 NAMECHAR ("D") #\D)
	(NAMECHAR69 NAMECHAR ("E") #\E)
	(NAMECHAR70 NAMECHAR ("F") #\F)
	(NAMECHAR71 NAMECHAR ("G") #\G)
	(NAMECHAR72 NAMECHAR ("H") #\H)
	(NAMECHAR73 NAMECHAR ("I") #\I)
	(NAMECHAR74 NAMECHAR ("J") #\J)
	(NAMECHAR75 NAMECHAR ("K") #\K)
	(NAMECHAR76 NAMECHAR ("L") #\L)
	(NAMECHAR77 NAMECHAR ("M") #\M)
	(NAMECHAR78 NAMECHAR ("N") #\N)
	(NAMECHAR79 NAMECHAR ("O") #\O)
	(NAMECHAR80 NAMECHAR ("P") #\P)
	(NAMECHAR81 NAMECHAR ("Q") #\Q)
	(NAMECHAR82 NAMECHAR ("R") #\R)
	(NAMECHAR83 NAMECHAR ("S") #\S)
	(NAMECHAR84 NAMECHAR ("T") #\T)
	(NAMECHAR85 NAMECHAR ("U") #\U)
	(NAMECHAR86 NAMECHAR ("V") #\V)
	(NAMECHAR87 NAMECHAR ("W") #\W)
	(NAMECHAR88 NAMECHAR ("X") #\X)
	(NAMECHAR89 NAMECHAR ("Y") #\Y)
	(NAMECHAR90 NAMECHAR ("Z") #\Z)
	(NAMECHAR94 NAMECHAR ("^") #\^)
	(NAMECHAR95 NAMECHAR ("_") #\_)
	(NAMECHAR97 NAMECHAR ("a") #\a)
	(NAMECHAR98 NAMECHAR ("b") #\b)
	(NAMECHAR99 NAMECHAR ("c") #\c)
	(NAMECHAR100 NAMECHAR  ("d") #\d)
	(NAMECHAR101 NAMECHAR  ("e") #\e)
	(NAMECHAR102 NAMECHAR  ("f") #\f)
	(NAMECHAR103 NAMECHAR  ("g") #\g)
	(NAMECHAR104 NAMECHAR  ("h") #\h)
	(NAMECHAR105 NAMECHAR  ("i") #\i)
	(NAMECHAR106 NAMECHAR  ("j") #\j)
	(NAMECHAR107 NAMECHAR ("k") #\k)
	(NAMECHAR108 NAMECHAR ("l") #\l)
	(NAMECHAR109 NAMECHAR ("m") #\m)
	(NAMECHAR110 NAMECHAR ("n") #\n)
	(NAMECHAR111 NAMECHAR ("o") #\o)
	(NAMECHAR112 NAMECHAR ("p") #\p)
	(NAMECHAR113 NAMECHAR ("q") #\q)
	(NAMECHAR114 NAMECHAR ("r") #\r)
	(NAMECHAR115 NAMECHAR ("s") #\s)
	(NAMECHAR116 NAMECHAR ("t") #\t)
	(NAMECHAR117 NAMECHAR ("u") #\u)
	(NAMECHAR118 NAMECHAR ("v") #\v)
	(NAMECHAR119 NAMECHAR ("w") #\w)
	(NAMECHAR120 NAMECHAR ("x") #\x)
	(NAMECHAR121 NAMECHAR ("y") #\y)
	(NAMECHAR122 NAMECHAR ("z") #\z)
	(NAMECHAR126 NAMECHAR ("~") #\~)
	(NAMECHAR126 NAMECHAR ("#") #\#)

	(NAMEBEGCHAR48 NAMEBEGCHAR ("0") #\0)
	(NAMEBEGCHAR49 NAMEBEGCHAR ("1") #\1)
	(NAMEBEGCHAR50 NAMEBEGCHAR ("2") #\2)
	(NAMEBEGCHAR51 NAMEBEGCHAR ("3") #\3)
	(NAMEBEGCHAR52 NAMEBEGCHAR ("4") #\4)
	(NAMEBEGCHAR53 NAMEBEGCHAR ("5") #\5)
	(NAMEBEGCHAR54 NAMEBEGCHAR ("6") #\6)
	(NAMEBEGCHAR55 NAMEBEGCHAR ("7") #\7)
	(NAMEBEGCHAR56 NAMEBEGCHAR ("8") #\8)
	(NAMEBEGCHAR57 NAMEBEGCHAR ("9") #\9)
	(NAMEBEGCHAR65 NAMEBEGCHAR ("A") #\A)
	(NAMEBEGCHAR66 NAMEBEGCHAR ("B") #\B)
	(NAMEBEGCHAR67 NAMEBEGCHAR ("C") #\C)
	(NAMEBEGCHAR68 NAMEBEGCHAR ("D") #\D)
	(NAMEBEGCHAR69 NAMEBEGCHAR ("E") #\E)
	(NAMEBEGCHAR70 NAMEBEGCHAR ("F") #\F)
	(NAMEBEGCHAR71 NAMEBEGCHAR ("G") #\G)
	(NAMEBEGCHAR72 NAMEBEGCHAR ("H") #\H)
	(NAMEBEGCHAR73 NAMEBEGCHAR ("I") #\I)
	(NAMEBEGCHAR74 NAMEBEGCHAR ("J") #\J)
	(NAMEBEGCHAR75 NAMEBEGCHAR ("K") #\K)
	(NAMEBEGCHAR76 NAMEBEGCHAR ("L") #\L)
	(NAMEBEGCHAR77 NAMEBEGCHAR ("M") #\M)
	(NAMEBEGCHAR78 NAMEBEGCHAR ("N") #\N)
	(NAMEBEGCHAR79 NAMEBEGCHAR ("O") #\O)
	(NAMEBEGCHAR80 NAMEBEGCHAR ("P") #\P)
	(NAMEBEGCHAR81 NAMEBEGCHAR ("Q") #\Q)
	(NAMEBEGCHAR82 NAMEBEGCHAR ("R") #\R)
	(NAMEBEGCHAR83 NAMEBEGCHAR ("S") #\S)
	(NAMEBEGCHAR84 NAMEBEGCHAR ("T") #\T)
	(NAMEBEGCHAR85 NAMEBEGCHAR ("U") #\U)
	(NAMEBEGCHAR86 NAMEBEGCHAR ("V") #\V)
	(NAMEBEGCHAR87 NAMEBEGCHAR ("W") #\W)
	(NAMEBEGCHAR88 NAMEBEGCHAR ("X") #\X)
	(NAMEBEGCHAR89 NAMEBEGCHAR ("Y") #\Y)
	(NAMEBEGCHAR90 NAMEBEGCHAR ("Z") #\Z)
	(NAMEBEGCHAR97 NAMEBEGCHAR ("a") #\a)
	(NAMEBEGCHAR98 NAMEBEGCHAR ("b") #\b)
	(NAMEBEGCHAR99 NAMEBEGCHAR ("c") #\c)
	(NAMEBEGCHAR100 NAMEBEGCHAR ("d") #\d)
	(NAMEBEGCHAR101 NAMEBEGCHAR ("e") #\e)
	(NAMEBEGCHAR102 NAMEBEGCHAR ("f") #\f)
	(NAMEBEGCHAR103 NAMEBEGCHAR ("g") #\g)
	(NAMEBEGCHAR104 NAMEBEGCHAR ("h") #\h)
	(NAMEBEGCHAR105 NAMEBEGCHAR ("i") #\i)
	(NAMEBEGCHAR106 NAMEBEGCHAR ("j") #\j)
	(NAMEBEGCHAR107 NAMEBEGCHAR ("k") #\k)
	(NAMEBEGCHAR108 NAMEBEGCHAR ("l") #\l)
	(NAMEBEGCHAR109 NAMEBEGCHAR ("m") #\m)
	(NAMEBEGCHAR110 NAMEBEGCHAR ("n") #\n)
	(NAMEBEGCHAR111 NAMEBEGCHAR ("o") #\o)
	(NAMEBEGCHAR112 NAMEBEGCHAR ("p") #\p)
	(NAMEBEGCHAR113 NAMEBEGCHAR ("q") #\q)
	(NAMEBEGCHAR114 NAMEBEGCHAR ("r") #\r)
	(NAMEBEGCHAR115 NAMEBEGCHAR ("s") #\s)
	(NAMEBEGCHAR116 NAMEBEGCHAR ("t") #\t)
	(NAMEBEGCHAR117 NAMEBEGCHAR ("u") #\u)
	(NAMEBEGCHAR118 NAMEBEGCHAR ("v") #\v)
	(NAMEBEGCHAR119 NAMEBEGCHAR ("w") #\w)
	(NAMEBEGCHAR120 NAMEBEGCHAR ("x") #\x)
	(NAMEBEGCHAR121 NAMEBEGCHAR ("y") #\y)
	(NAMEBEGCHAR122 NAMEBEGCHAR ("z") #\z)

	(STRING1 STRING NIL "")
	(STRING2 STRING (NAMECHAR STRING) 
		 #'(lambda (ch str)
		     (format nil "~d~d" ch str)))
	(STRING3 STRING ("." STRING) 
		 #'(lambda (str)
		     (format nil ".~d" str)))
	(STRING4 STRING (WH STRING) 
		 #'(lambda (str)
		     (format nil " ~d" str)))

	(STRINGL1 QSTRINGL ("\"" STRING "\"") #'list)
	(STRINGL2 QSTRINGL ("\"" STRING "\"" "," WH QSTRINGL) #'cons)
	))

(defvar *pre-input1-global-sigma* nil)
(defvar *input1-ctx-info* nil)
(defvar *input1-state* nil)

(defvar *infix-at-op* '|binunion|)
(defvar *infix-at2-op* '|binunion|)
(defvar *infix-plus-op* '|binunion|)
(defvar *infix-plus2-op* '|binunion|)
(defvar *infix-star-op* '|cartprod|)
(defvar *infix-star2-op* '|binintersect|)
(defvar *infix-minus-op* '|setminus|)
(defvar *infix-minus2-op* '|setminus|)
(defvar *infix-slash-op* '|setminus|)
(defvar *infix-slash2-op* '|setminus|)
(defvar *infix-less-op* '|subset|)
(defvar *infix-greater-op* '|imp|)
(defvar *infix-leq-op* '|subset|)
(defvar *infix-geq-op* '|imp|)

(defvar *input1-ctx-stack* nil)

(defvar *input1-state-names* nil)

(defvar *input1-last-claim* nil)

(defvar *authors* nil)

(setq input1-grammar (grules-to-grammar input1-grules))

(defvar grammar input1-grammar)

(dolist (c input1-gcats)
  (unless (assoc c input1-grammar)
    (push (list c) input1-grammar)))

(defun initialize-input1-globals ()
  (setq *input1-ctx-info* nil)
;  (setq *input1-state* nil)
  (setq *pre-input1-global-sigma* *global-sigma*)
  (setq *authors* nil)
  (setq *input1-last-claim* nil)
  (setq grammar input1-grammar)
  (setq *linecomment-chars* '(#\%))
  )

(defun backtrack-input1-globals (oldstatename)
  (unless oldstatename
    (if *input1-state-names*
	(setq oldstatename (car *input1-state-names*))
      (fail "cannot backtrack - no previous statenames")))
;  (setq *input1-state* nil)
  (setq *input1-ctx-info* (get oldstatename '*input1-ctx-info*))
  (setq *input1-state* (get oldstatename '*input1-state*))
  (setq *timestamp* (get oldstatename '*timestamp*))
  (setq *global-sigma* (get oldstatename '*global-sigma*))
  (setq grammar (get oldstatename 'grammar))
  (setq *linecomment-chars* '(#\%))
  )

(defun record-input1-state ()
  (let ((g (intern-gensym "ST")))
    (push g *input1-state-names*)
    (setf (get g '*input1-ctx-info*) *input1-ctx-info*)
    (setf (get g '*input1-state*) *input1-state*)
    (setf (get g '*timestamp*) *timestamp*)
    (setf (get g '*global-sigma*) *global-sigma*)
    (setf (get g 'grammar) grammar)
    g))

(defun pop-input1-ctx ()
  (clear-bvars (mapcar #'car *input1-ctx-info*))
  (setq *input1-ctx-info* (pop *input1-ctx-stack*))
  (dolist (xm *input1-ctx-info*)
    (setf (get (car xm) 'bvar) t)
    (setf (get (car xm) 'dbtype) (cadar (cadr xm)))))
  
(defun push-input1-ctx ()
  (push *input1-ctx-info* *input1-ctx-stack*))

(defun readinput1 (filename)
  (initialize-input1-globals)
;  (open-tex-log)
  (s-readinput1-real filename)
;  (close-tex-log)
  (clear-bvars (mapcar #'car *input1-ctx-info*))
  )

(defun clear-bvars (xl)
  (dolist (x xl)
    (setf (get x 'bvar) nil)
    (setf (get x 'dbtype) nil)))

(defun retryinput1 (filename &optional oldstatename)
  (backtrack-input1-globals oldstatename)
;  (open-tex-log)
  (s-readinput1-real filename)
;  (close-tex-log)
  (clear-bvars (mapcar #'car *input1-ctx-info*))
)

(defun s-readinput1-real (filename)
  (if (or (probe-file filename) (probe-file (format nil "~d.pam" filename)))
      (readinput1-real filename)
    (if (and *scunak-main-dir*
	     (or
	      (probe-file (format nil "~d/~d" *scunak-main-dir* filename))
	      (probe-file (format nil "~d/~d.pam" *scunak-main-dir* filename))))
	(readinput1-real (format nil "~d/~d" *scunak-main-dir* filename))
      (fail (format nil "No file named ~d." filename)))))

(defun readinput1-real (filename)
  (declare (special grammar))
  (setq *input1-ctx-info* nil)
  (unless (s-probe-file filename)
    (if (s-probe-file (format nil "~d.pam" filename))
	(setq filename (format nil "~d.pam" filename))
      (fail "Could not find pam file" filename)))
  (let ((s (open filename :direction :input)))
    (let ((*last-char* (read-char s nil nil))
	  (*position* 0))
      (declare (special *last-char* *position*))
      (let ((*last-token* (read-token s))
	    (failed nil)
	    (failinfo nil))
	(declare (special *last-token*))
	(do ((i
	      (parse-stream s 'DOCUMENTITEM grammar 0)
	      (parse-stream s 'DOCUMENTITEM grammar 0)))
	    ((null i)
	     (close s))
	    (multiple-value-setq
	     (grammar failed failinfo)
	     (process-parsed-input (cadr i) grammar))
	    (when failed
	      (format t "Failed to process ~d~%" (car i))
	      (dolist (x failinfo)
		(format t "~d~%" x))
	      (fail ""))
	    )))))

(defun input1-newvar (x pre-dtp)
  (if (or (stringp x) (symbolp x))
  (let ((xname (intern x))
	(ctxi *input1-ctx-info*))
    (if (usedname-p xname)
	(values nil (format nil "name ~d is already used" x))
      (progn
	(let ((a (assoc xname *input1-ctx-info*))) ; already a bvar
	  (when a
	    (when (> *verbose* 20)
	      (format t "Already a bdvar ~d, deleting old version~%" x))
	    (setq ctxi (remove-bdvar xname *input1-ctx-info*))))
	(multiple-value-bind
	 (dtp info fail)
	 (deptype-fill-in-blanks pre-dtp *input1-state*
				 (input1-blanks-prefix ctxi)
				 )
	 (if (or fail info)
	     (values nil (or fail (cons 'UNSOLVED-CONSTRAINTS info)))
	   (progn
	     (input1-add-var-to-ctx xname (normalize-type dtp) ctxi)
	     t))))))
  (fail "cannot be a bvar" x)))

; dtp should be normal
(defun input1-add-var-to-ctx (newvar dtp &optional (ctxi *input1-ctx-info*))
  (let* ((frees (dtype-free-bvars dtp))
	 (mctx (build-minimal-ctx frees ctxi))
	 (detdeps nil))
    (setf (get newvar 'bvar) t)
    (setf (get newvar 'dbtype) dtp)
    (push (list newvar (cons (list newvar dtp) mctx))
	  ctxi)
    (when (> *verbose* 45)
      (format t "Adding ~d of type ~d to ctx~%" newvar dtp))
    (setq *input1-ctx-info* ctxi)))

; we may also need to remove coercions if they depend on local bvars
(defun remove-bdvar (v ctx-info)
  (let ((c (assoc 'coercions *input1-state*))
	(removed nil)
	(ret nil))
    (setq ret
	  (remove-if #'(lambda (a)
			 (let ((z (assoc v (cadr a))))
			   (if z
			       (progn
				 (setf (get (car a) 'bvar) nil)
				 (push (car a) removed)
				 t)
			     nil)))
		     ctx-info))
    (when c
      (setq *input1-state*
	    (acons 'COERCIONS
		   (remove-if #'(lambda (c0)
				  (intersection (mapcar #'car (car c0)) removed)
				  )
			      (cdr c))
		   (remove c *input1-state*))))
    ret))

(defun input1-newconst (newapp pre-dtp &optional allow-evars)
  (let ((ctxi *input1-ctx-info*)
	(name (if (consp newapp) (car newapp) newapp))
	(expldeps (if (consp newapp) (cdr newapp) nil)))
    (let ((a (assoc name *input1-ctx-info* :test #'equal))) ; already a bdvar
      (when a
	(when (> *verbose* 20)
	  (format t "Already a bdvar ~d, deleting this~%" name))
	(setq ctxi (remove-bdvar (cadr a) *input1-ctx-info*)))
      (multiple-value-bind
       (argctx failinfo)
       (varlist-to-ctx expldeps ctxi)
       (if failinfo
	   (values nil failinfo)
	 (multiple-value-bind
	  (dtp info fail)
	  (deptype-fill-in-blanks pre-dtp *input1-state* 
				  (input1-blanks-prefix-2 argctx))
	  (if fail
	      (values nil fail)
	    (progn
	      (when (and info allow-evars)
		(setq info (input1-handle-underspec info)))
	      (if info
		  (values nil (cons 'UNSOLVED-CONSTRAINTS info))
		(let ((fdtp (normalize-type dtp)))
		  (let ((mctx (build-minimal-ctx (dtype-free-bvars fdtp) ctxi)))
		    (if (subctx mctx argctx)
			(let ((fdtp (prefix-dpi-db argctx fdtp)))
			  (newconst name (normalize-type fdtp) *authors*))
		      (values nil (format nil "Hidden Dependency for new const ~d~%" name))))))))))))))

(defun input1-newclaim (newapp pre-dtp &optional allow-evars)
  (let ((ctxi *input1-ctx-info*)
	(name (if (consp newapp) (car newapp) newapp))
	(expldeps (if (consp newapp) (cdr newapp) nil)))
    (let ((a (assoc name *input1-ctx-info* :test #'equal))) ; already a bdvar
      (when a
	(when (> *verbose* 20)
	  (format t "Already a bdvar ~d, deleting this~%" name))
	(setq ctxi (remove-bdvar (cadr a) *input1-ctx-info*)))
      (multiple-value-bind
       (argctx failinfo)
       (varlist-to-ctx expldeps ctxi)
       (if failinfo
	   (values nil failinfo)
	 (multiple-value-bind
	  (dtp info fail)
	  (deptype-fill-in-blanks pre-dtp *input1-state*
				  (input1-blanks-prefix-2 argctx))
	  (if fail
	      (values nil fail)
	    (progn
	      (when (and info allow-evars)
		(setq info (input1-handle-underspec info)))
	      (if info
		  (values nil (cons 'UNSOLVED-CONSTRAINTS info))
		(let ((fdtp (normalize-type dtp)))
		  (let ((mctx (build-minimal-ctx (dtype-free-bvars fdtp) ctxi)))
		    (if (subctx mctx argctx)
			(progn
			  (setq *input1-last-claim* (list name argctx fdtp))
			  (let ((fdtp (prefix-dpi-db argctx fdtp)))
			    (newclaim name (normalize-type fdtp) *authors*)))
		      (values nil (format nil "Hidden Dependency for new claim ~d~%" name))))))))))))))

(defun input1-newabbrev (newapp pre-dtp pre-defn &optional allow-evars)
  (let ((ctxi *input1-ctx-info*)
	(name (if (consp newapp) (car newapp) newapp))
	(expldeps (if (consp newapp) (cdr newapp) nil)))
    (let ((a (assoc name *input1-ctx-info* :test #'equal))) ; already a bdvar
      (when a
	(when (> *verbose* 20)
	  (format t "Already a bdvar ~d, deleting this~%" name))
	(setq ctxi (remove-bdvar (cadr a) *input1-ctx-info*)))
      (multiple-value-bind
       (argctx failinfo)
       (varlist-to-ctx expldeps ctxi)
       (if failinfo
	   (values nil failinfo)
	 (multiple-value-bind
	  (dtp info fail)
	  (deptype-fill-in-blanks pre-dtp *input1-state*
				  (input1-blanks-prefix-2 argctx))
	  (if fail
	      (values nil fail)
	    (progn
	      (when (and info allow-evars)
		(setq info (input1-handle-underspec info)))
	      (if info
		  (values nil (cons 'UNSOLVED-CONSTRAINTS info))
		(multiple-value-bind
		 (defn info fail)
		 (normal-fill-in-blanks pre-defn dtp *input1-state* (input1-blanks-prefix-2 argctx))
		 (if fail
		     (values nil fail)
		   (progn
		     (when (and info allow-evars)
		       (setq info (input1-handle-underspec info)))
		     (if info
			 (values nil (cons 'UNSOLVED-CONSTRAINTS info))
		       (let ((fdtp (normalize-type dtp))
			     (ldefn (normalize defn)))
			 (let ((mctx2 (build-minimal-ctx (append (dtype-free-bvars fdtp)
								 (free-bvars ldefn))
							 ctxi)))
			   (if (subctx mctx2 argctx)
			       (let* ((fdtp (prefix-dpi-db argctx fdtp))
				      (ldefn (prefix-lam-db argctx ldefn)))
				 (if (claimname-p name)
				     (if (heq fdtp (get name 'dbtype))
					 (claim2abbrev name ldefn *authors*)
				       (fail (format nil "given type of ~d does not match type of claim" name)
					     name fdtp ldefn))
				   (newabbrev name (normalize-type fdtp) (normalize ldefn) *authors* *authors*)))
			     (values nil (format nil "Hidden Dependency for new abbrev ~d~%" name))))))))))))))))))

(defun input1-newabbrev-extr (newapp pre-defn &optional allow-evars)
  (let ((ctxi *input1-ctx-info*)
	(name (if (consp newapp) (car newapp) newapp))
	(expldeps (if (consp newapp) (cdr newapp) nil)))
    (let ((a (assoc name *input1-ctx-info* :test #'equal))) ; already a bdvar
      (when a
	(when (> *verbose* 20)
	  (format t "Already a bdvar ~d, deleting this~%" name))
	(setq ctxi (remove-bdvar (cadr a) *input1-ctx-info*)))
      (multiple-value-bind
       (argctx failinfo)
       (varlist-to-ctx expldeps ctxi)
       (if failinfo
	   (values nil failinfo)
	 (multiple-value-bind
	  (defn dtp info fail)
	  (extr-fill-in-blanks-1 pre-defn *input1-state* (input1-blanks-prefix-2 argctx))
;	  (if (consp pre-defn)
;	      (app-fill-in-blanks-0 (car pre-defn) (cdr pre-defn) *input1-state* (input1-blanks-prefix-2 argctx) nil)
;	    (app-fill-in-blanks-0 pre-defn nil *input1-state* (input1-blanks-prefix-2 argctx) nil))
	  (if fail
	      (values nil fail)
	    (progn
	      (when (and info allow-evars)
		(setq info (input1-handle-underspec info)))
	      (if info
		  (values nil (cons 'UNSOLVED-CONSTRAINTS info))
		(let ((fdtp (normalize-type dtp))
		      (ldefn (normalize defn)))
		  (let ((mctx2 (build-minimal-ctx (append (dtype-free-bvars fdtp)
							  (free-bvars ldefn))
						  ctxi)))
		    (if (subctx mctx2 argctx)
			(let* ((fdtp (prefix-dpi-db argctx fdtp))
			       (ldefn (prefix-lam-db argctx ldefn)))
			  (if (claimname-p name)
			      (if (heq fdtp (get name 'dbtype))
				  (claim2abbrev name ldefn *authors*)
				(fail (format nil "given type of ~d does not match type of claim" name)
				      name fdtp ldefn))
			    (newabbrev name (normalize-type fdtp) (normalize ldefn) '("AUTO") *authors*)))
		      (values nil (format nil "Hidden Dependency for new abbrev ~d~%" name))))))))))))))

(defun input1-claim2abbrev (newapp pre-defn &optional allow-evars)
  (let ((ctxi *input1-ctx-info*)
	(name (if (consp newapp) (car newapp) newapp))
	(expldeps (if (consp newapp) (cdr newapp) nil)))
    (let ((a (assoc name *input1-ctx-info* :test #'equal))) ; already a bdvar
      (when a
	(when (> *verbose* 20)
	  (format t "Already a bdvar ~d, deleting this~%" name))
	(setq ctxi (remove-bdvar (cadr a) *input1-ctx-info*)))
      (multiple-value-bind
       (argctx failinfo)
       (varlist-to-ctx expldeps ctxi)
       (if failinfo
	   (values nil failinfo)
	 (if (claimname-p name)
	     (let* ((dtp (get name 'dbtype)))
	       (dolist (xtp (reverse argctx))
		 (if (dpi-p dtp)
		     (if (heq (dpi-dom dtp) (cadr xtp))
			 (setq dtp (dbsubst-type-0 (dpi-cod dtp) (car xtp)))
		       (fail "type mismatch with explicit arguments between claim and defn" name dtp xtp))
		   (fail "too many expl arguments for claim" name dtp xtp)))
	       (multiple-value-bind
		(defn info fail)
		(normal-fill-in-blanks pre-defn dtp *input1-state* (input1-blanks-prefix-2 argctx))
		(if fail
		    (values nil fail)
		  (progn
		    (when (and info allow-evars)
		      (setq info (input1-handle-underspec info)))
		    (if info
			(values nil (cons 'UNSOLVED-CONSTRAINTS info))
		      (let ((ldefn (normalize defn)))
			(let ((mctx2 (build-minimal-ctx (free-bvars ldefn)
							ctxi)))
			  (if (subctx mctx2 argctx)
			      (let* ((ldefn (prefix-lam-db argctx ldefn)))
				(claim2abbrev name ldefn *authors*))
			    (values nil (format nil "Hidden Dependency for new abbrev ~d~%" name))))))))))
	   (fail (format nil "~d is not a claim" name) name)))))))

(defun build-minimal-ctx (vars ctxi)
  (if vars
      (combine-ctxs
       (get-minimal-ctx (car vars) ctxi)
       (build-minimal-ctx (cdr vars) ctxi))
    nil))

; post x ctx (take cdr to get pre x ctx)
(defun get-minimal-ctx (var ctxi)
  (let ((a (find-if #'(lambda (y)
			(equal (caaadr y) var))
		    ctxi)))
    (if a
	(cadr a) ; post - x ctx
      (fail (format nil "missing ctx var ~d" var)))))

; zips contexts together, maintaining validity
; assumes ctx1 and ctx2 are valid
(defun combine-ctxs (ctx1 ctx2)
  (if ctx1
      (adjoin-to-ctx (caar ctx1) (cdar ctx1)
		     (combine-ctxs (cdr ctx1) ctx2))
    ctx2))

(defun adjoin-to-ctx (x rst ctx)
  (if (assoc x ctx :test #'equal)
      ctx
    (cons (cons x rst) ctx)))

; assumes ctx1 and ctx2 are valid, and consistent (assign same dep types to bvars)
(defun subctx (ctx1 ctx2)
  (if ctx1
      (and (assoc (caar ctx1) ctx2 :test #'equal)
	   (subctx (cdr ctx1) ctx2))
    t))

(defun varlist-to-ctx (varlist &optional (ctxi *input1-ctx-info*))
  (let ((ctx nil)
	(failinfo nil))
    (dolist (xname varlist)
      (let ((a (assoc xname ctxi)))
	(if a
	    (let ((post-x-ctx (cadr a)))
	      (if (subctx (cdr post-x-ctx) ; pre-x ctx contained in ctx
			  ctx)
		  (push (car post-x-ctx) ctx) ; push (x : A) onto ctx
		(setq failinfo (format nil "invalid ctx for bvar ~d" xname))))
	  (setq failinfo (format nil "unknown bvar ~d" xname)))))
    (if failinfo
	(values nil failinfo)
      ctx)))

(defun input1-blanks-prefix (ctxi)
  (mapcar #'(lambda (a)
	      (list (car a)
		    (cadr (caadr a))))
	  ctxi))

(defun input1-blanks-prefix-2 (argctx)
  argctx)

(defun input1-handle-underspec (info)
  (if (find-if-not #'(lambda (x) (eq (car x) 'EVAR)) info)
      info
    ; all evars, add them as claims
    (progn
      (when (> *verbose* 10)
	(format t "****** UNDERSPECIFICATION *****~%" info)
	(when (> *verbose* 20)
	  (format t "Adding Implicit Evars~%")))
      (dolist (ev info)
	(newclaim (cadr ev) (normalize-type (caddr ev))))
      nil)))

; code for translating from named form (for bvars in ctx, not yet bound) to db form
(defun named-term-to-db (namectx trm)
  (named-term-to-db-1 (mapcar #'car namectx) trm))

(defun named-term-to-db-1 (names trm)
  (cond ((app-p trm)
	 (app (named-term-to-db-1 names (app-func trm))
	      (named-term-to-db-1 names (app-arg trm))))
	((lam-p trm)
	 (lam (named-term-to-db-1 (cons nil names) (lam-body trm))))
	((pair-p trm)
	 (pair (named-term-to-db-1 names (pair-fst trm))
	       (named-term-to-db-1 names (pair-snd trm))))
	((fst-p trm)
	 (fst (named-term-to-db-1 names (fst-arg trm))))
	((snd-p trm)
	 (snd (named-term-to-db-1 names (snd-arg trm))))
	(t
	 (let ((p (position trm names)))
	   (or p trm)))))

(defun named-type-to-db (namectx tp)
  (named-type-to-db-1 (mapcar #'car namectx) tp))

(defun named-type-to-db-1 (names tp)
  (cond ((dpi-p tp)
	 (dpi (named-type-to-db-1 names (dpi-dom tp))
	      (named-type-to-db-1 (cons nil names) (dpi-cod tp))))
	((dclass-p tp)
	 (dclass (named-term-to-db-1 names (dclass-pred tp))))
	((pf-p tp)
	 (pf (named-term-to-db-1 names (pf-prop tp))))
	(t tp)))

; replace x with db index n, assumes no 'free' db indices
(defun quick-db-type (x n tp)
  (cond ((dpi-p tp)
	 (dpi (quick-db-type x n (dpi-dom tp))
	      (quick-db-type x (1+ n) (dpi-cod tp))))
	((dclass-p tp)
	 (dclass (quick-db-term x n (dclass-pred tp))))
	((pf-p tp)
	 (pf (quick-db-term x n (pf-prop tp))))
	(t tp)))

(defun quick-db-term (x n trm)
  (cond ((app-p trm)
	 (app (quick-db-term x n (app-func trm))
	      (quick-db-term x n (app-arg trm))))
	((lam-p trm)
	 (lam (quick-db-term x (1+ n) (lam-body trm))))
	((pair-p trm)
	 (pair (quick-db-term x n (pair-fst trm))
	       (quick-db-term x n (pair-snd trm))))
	((fst-p trm)
	 (fst (quick-db-term x n (fst-arg trm))))
	((snd-p trm)
	 (snd (quick-db-term x n (snd-arg trm))))
	((eq x trm) n)
	(t trm)))

(defun prefix-dpi-db (prefix dtp)
  (if prefix
      (prefix-dpi-db (cdr prefix)
		     (dpi (named-type-to-db (cdr prefix) (cadar prefix))
			  (quick-db-type (caar prefix) 0 dtp)))
    dtp))

(defun prefix-lam-db (prefix trm)
  (if prefix
      (prefix-lam-db (cdr prefix)
		     (lam (quick-db-term (caar prefix) 0 trm)))
    trm))

(defun set-authors (strl)
  (setq *authors* strl))

(defun input1-dibe (i el)
  (if *input1-last-claim*
      (let ((goal (car *input1-last-claim*))
	    (argctx (cadr *input1-last-claim*))
	    (dtp (caddr *input1-last-claim*))
	    (fakegoal (intern-gensym)))
	(setq *enumeration-cycles* 0)
	(setq *sos-types* nil)
	(setq *usable-types* (list (list *emptyctx* (obj) 0) (list *emptyctx* (prop) 0)))
	(setq *sos-normals* nil)
	(setq *usable-normals* nil)
	(setq *sos-extractions* nil)
	(setq *usable-extractions* nil)
	(setq *max-ctx-len* i)
	(when (> *verbose* 20)
	  (format t "Calling dibe for ~d~%" goal))
	(dolist (e el)
	  (multiple-value-bind
	   (strm sdtp info fail)
	   (extr-fill-in-blanks-1 e *input1-state* (input1-blanks-prefix-2 argctx))
;	   (if (consp e)
;	       (app-fill-in-blanks-0 (car e) (cdr e) *input1-state* (input1-blanks-prefix-2 argctx) nil)
;	     (app-fill-in-blanks-0 e nil *input1-state* (input1-blanks-prefix-2 argctx) nil))
	   (if (or info fail)
	       (fail "Could not form extraction for sos of dibe" e (or info fail))
	     (progn
	       (push (list *emptyctx* strm sdtp 0) *sos-extractions*)))))
	(dolist (c *global-sigma*)
	  (unless (>= (get c 'timestamp) (get goal 'timestamp))
	    (push (list *emptyctx* c (get c 'dbtype) (get c 'timestamp)) *usable-extractions*)))
	(setf (get fakegoal 'timestamp) (get goal 'timestamp))
	(setf (get fakegoal 'claim) t)
	(setf (get fakegoal 'dbtype) dtp)
	(setf (get fakegoal 'proposed-solns) nil)
	(setq *goal-normals* (list fakegoal))
	(setq *enumerate-throw-on-success* t)
	(let ((trm (catch 'success (enumerate))))
	  (unless trm
	    (when (> *verbose* 10)
	      (format t "dibe failed~%")))
	  t))
    (fail "dibe called before any claim has been made" el)))

(defun input1-iprove ()
  (if *input1-last-claim*
      (let ((goal (car *input1-last-claim*))
	    (argctx (cadr *input1-last-claim*))
	    (dtp (caddr *input1-last-claim*)))
	(if (dtype-returns-pf-p dtp)
	    (let* ((usable-rules nil)
		   (usable-class-rules nil)
		   (evar (intern-gensym))
		   (fill-constraints (list (list *emptyctx* evar dtp argctx))))
	      (setf (get evar 'evar) t)
	      (setf (get evar 'dbtype) dtp)
	      (when (> *verbose* 20)
		(format t "Calling iprove for ~d~%" goal))
	      (dolist (c *global-sigma*)
		(when (and (< (get c 'timestamp) (get goal 'timestamp)))
		  (if (dtype-returns-pf-p (get c 'dbtype))
		      (push (list c (get c 'dbtype)) usable-rules)
		    (when (dtype-returns-dclass-p (get c 'dbtype))
		      (push (list c (get c 'dbtype)) usable-class-rules)))))
	      (dolist (c argctx)
		(if (dtype-returns-pf-p (cadr c))
		    (push (list (car c) (cadr c)) usable-rules)
		  (when (dtype-returns-dclass-p (cadr c))
		    (push (list (car c) (cadr c)) usable-class-rules))))
	      (multiple-value-bind
	       (trm fail)
	       (iprove evar fill-constraints nil usable-rules usable-class-rules)
	       (if fail
		   (when (> *verbose* 10)
		     (format t "iprove failed~%~d~%" fail))
		 (if (and trm (null (free-evars trm)))
		     (let* ((fdtp (prefix-dpi-db argctx fdtp))
			    (ldefn (prefix-lam-db argctx trm)))
		       (newabbrev name (normalize-type fdtp) (normalize ldefn)))
		   (when (> *verbose* 10)
		     (format t "iprove failed~%"))))
	       t))
	  (fail "iprove called, but last claim was not of proof type" goal argctx dtp)))
    (fail "iprove called before any claim has been made" el)))

(defun create-input1-coercion (pftrm0)
  (multiple-value-bind
   (pftrm1 tp1 info fail)
   (extr-fill-in-blanks-1 pftrm0 *input1-state*
			  (input1-blanks-prefix *input1-ctx-info*))
   (if (or info fail)
       (fail "Could not extract type for proof term for coercion" pftrm0)
     (let ((mctx (build-minimal-ctx (append (dtype-free-bvars tp1) (free-bvars pftrm1)) *input1-ctx-info*)))
       (cond ((and (pf-p tp1)
		   (isubset-p (pf-prop tp1)))
	      (let ((fromset (app-arg (app-func (pf-prop tp1))))
		    (toset (app-arg (pf-prop tp1))))
		(setq *input1-state*
		      (add-coercion-to-state #'(lambda (trm fromtp totp)
						 (if (and (dclass-p fromtp)
							  (dclass-p totp)
							  (app-p (dclass-pred fromtp))
							  (app-p (dclass-pred totp))
							  (eq (app-func (dclass-pred fromtp)) '|in|)
							  (eq (app-func (dclass-pred totp)) '|in|)
							  (ctx-terms-eq-type *emptyctx* (app-arg (dclass-pred fromtp)) fromset (obj))
							  (ctx-terms-eq-type *emptyctx* (app-arg (dclass-pred totp)) toset (obj)))
						     (pair (gen-pair-fst trm)
							   (app-n '|subsetE|
								  (list fromset toset (gen-pair-fst trm)
									pftrm1
									(gen-pair-snd trm))))
						   nil))
					     mctx
					     *input1-state*
					     ))))
	     (t
	      (fail "Could not determine a coercion from given proof term" pftrm0 tp1))))))
  t)

(defun input1-sigma ()
  (let ((ret nil))
    (dolist (c *global-sigma*)
      (unless (member c *pre-input1-global-sigma*)
	(push c ret)))
    ret))

(defun db-ctx-info (ctxi)
  (if ctxi
      (ctx-cons (named-type-to-db-1 (mapcar #'car (cdr ctxi)) (cadar (cadar ctxi)))
		(db-ctx-info (cdr ctxi)))
    *emptyctx*))

; reading using pam style S-expressions instead of parsing...
(setq input1-tol-grules
      '(
	(CONTEXT1 DOCUMENTITEM ("[" NAME ":" DTYPE1 "]")
		  #'(lambda (x dtp)
		      (format *compile-input1-out* "(LET ~S ~S)~%"
			      x dtp)
		      t)
		  )
	(CONST1 DOCUMENTITEM (NEWAPP ":" DTYPE2 ".")
		#'(lambda (x dtp)
		    (format *compile-input1-out*
			    "(CONST ~S~% ~S)~%"
			    x dtp)
		    t))
	(CLAIM1 DOCUMENTITEM (NEWAPP ":" DTYPE2 "?")
		#'(lambda (x dtp)
		    (format *compile-input1-out*
			    "(CLAIM ~S~% ~S)~%"
			    x dtp)
		    t))
	(ABBREV1 DOCUMENTITEM (NEWAPP ":" DTYPE2 WH "=" NORMAL ".")
		#'(lambda (x dtp defn)
		    (format *compile-input1-out*
			    "(ABBREV ~S~% ~S~% ~S)~%"
			    x dtp defn)
		    t))
	(ABBREV2 DOCUMENTITEM (NEWAPP ":" DTYPE2 "=" NORMAL ".")
		#'(lambda (x dtp defn)
		    (format *compile-input1-out*
			    "(ABBREV ~S~% ~S~% ~S)~%"
			    x dtp defn)
		    t))
	(ABBREV3 DOCUMENTITEM (NEWAPP "=" EXTRACT ".")
		#'(lambda (x defn)
		    (format *compile-input1-out*
			    "(ABBREVE ~S~% ~S)~%"
			    x defn)
		    t))
	(ABBREV3 DOCUMENTITEM (NEWAPP ":=" NORMAL ".")
		#'(lambda (x defn)
		    (format *compile-input1-out*
			    "(CLAIM2ABBREV ~S~% ~S)~%"
			    x defn)
		    t))

	(ABBREV1 DOCUMENTITEM (NEWAPP ":" DTYPE2 WH "=" NORMAL "?")
		#'(lambda (x dtp defn)
		    (format *compile-input1-out*
			    "(ABBREV ~S~% ~S~% ~S)~%"
			    x dtp defn)
		    t))
	(ABBREV2 DOCUMENTITEM (NEWAPP ":" DTYPE2 "=" NORMAL "?")
		#'(lambda (x dtp defn)
		    (format *compile-input1-out*
			    "(ABBREV ~S~% ~S~% ~S)~%"
			    x dtp defn)
		    t))
	(ABBREV3 DOCUMENTITEM (NEWAPP "=" EXTRACT "?")
		#'(lambda (x defn)
		    (format *compile-input1-out*
			    "(ABBREVE ~S~% ~S)~%"
			    x defn)
		    t))
	(ABBREV3 DOCUMENTITEM (NEWAPP ":=" NORMAL "?")
		#'(lambda (x defn)
		    (format *compile-input1-out*
			    "(CLAIM2ABBREV ~S~% ~S)~%"
			    x defn)
		    t))

	(COERCION1 DOCUMENTITEM ("coercion" WH EXTRACT ".")
		   #'(lambda (pftrm0)
		       (format *compile-input1-out*
			       "(COERCION ~S)~%"
			       pftrm0)
		       t))

	(NOTATIONINF DOCUMENTITEM ("notation" WH UBINOP WH EXTRACT ".")
		   #'(lambda (op defn)
		       (format *compile-input1-out*
			       "(NOTATION-INFIX ~S ~S)~%"
			       op defn)
		       t))
	(NOTATIONB DOCUMENTITEM ("notation" WH NAME WH EXTRACT ".")
		   #'(lambda (n defn)
		       (format *compile-input1-out*
			       "(NOTATION ~S ~S)~%"
			       n defn)
		       t))

	(LOAD DOCUMENTITEM ("load" WH "\"" STRING "\"!")
	      #'(lambda (filename)
		  (format *compile-input1-out*
			  "(LOAD ~S)~%" filename)
		  t))
	(LOADL DOCUMENTITEM ("loadl" WH "\"" STRING "\"!")
	      #'(lambda (filename)
		  (format *compile-input1-out*
			  "(LOADL ~S)~%" filename)
		  t))

	(AUTH1 DOCUMENTITEM ("author" WH "\"" STRING "\"!") ; do string
	       #'(lambda (str)
		   (format *compile-input1-out*
			   "(AUTHOR ~S)~%"
			   str)
		   t))
	(AUTH2 DOCUMENTITEM ("authors" WH QSTRINGL "!") ; do stringl
	       #'(lambda (strl)
		   (format *compile-input1-out*
			   "~S~%"
			   (cons 'AUTHORS strl))
		   t))

	(SCI1 SCI-ITEM ("[" NAME ":" DTYPE1 "]")
	      #'(lambda (x dtp) (sci-newvar x dtp))
	      )
	(SCI1 SCI-ITEM ("assume" WH DTYPE1 ".")
	      #'(lambda (dtp) (sci-assume dtp))
	      )
	(SCI2 SCI-ITEM ("check" WH EXTRACT ".") #'(lambda (x) (sci-check x)))
	(SCI3 SCI-ITEM ("q.") (SCI-QUIT-COMMAND))

	(LOAD TOP-ITEM ("load" WH "\"" STRING "\"")
	      #'(lambda (filename)
		  (record-input1-state)
		  (setq grammar input1-grammar)
		  (setq *linecomment-chars* '(#\%))
		  (when (> *verbose* 1)
		    (format t "Loading ~d~%" filename))
		  (s-readinput1-real filename)))
	(LOADL TOP-ITEM ("loadl" WH "\"" STRING "\"")
	      #'(lambda (filename)
		  (record-input1-state)
		  (setq filename (format nil "~d.lisp" filename))
		  (when (> *verbose* 1)
		    (format t "Loading Lisp ~d~%" filename))
		  (s-load filename)))
	(SCI3 TOP-ITEM ("lisp") (TOP-LISP-COMMAND))
	(SCI3 TOP-ITEM ("q.") (TOP-QUIT-COMMAND))
	(SCI3 TOP-ITEM ("q") (TOP-QUIT-COMMAND))
;	(SCI3 TOP-ITEM ("load" WH "\"" STRING "\"!")
;              #'(lambda (filename)
;		  (readinput1-real filename)))
;	(SCI3 TOP-ITEM ("loadl" WH "\"" STRING "\"!")
;              #'(lambda (filename)
;		  (load filename)))
	(SCI3 TOP-ITEM ("tutor" WH NEWAPP)
	      #'(lambda (c)
		  (setq *tutor-nl* nil)
		  (tutor-claim c)))
	(SCI3 TOP-ITEM ("nltutor" WH NEWAPP)
	      #'(lambda (c)
		  (setq *tutor-nl* t)
		  (tutor-claim c)))
	(SCI3 TOP-ITEM ("proofread" WH "\"" STRING "\"" WH NEWAPP ".")
	      #'(lambda (filename newapp)
		  (proofread filename newapp)))
	(DITOP TOP-ITEM (DOCUMENTITEM) #'identity)
	(DI TOP-ITEM ("help")
	    (print-help-top))
	(DI TOP-ITEM ("help" WH NAME) #'(lambda (x) (print-help-name (intern x))))
	(SCI3 TOP-ITEM ("vampire" WH NAME) 
	      #'(lambda (xs)
		  (let* ((x (intern xs))
			 (ts (get x 'timestamp)))
		    (if (and (claimname-p x) ts)
			(if (dtype-returns-pf-p (get x 'dbtype))
			    (if (vampire-res-fill-claim x
							(remove-if-not #'(lambda (z)
									   (< (get z 'timestamp) ts))
								       *global-sigma*))
				(format t "*Vampire found a refutation!*~%")
			      (format t "Vampire did not find a refutation.~%"))
			  (format t "~d does not have a proof type.~%" x))
		      (format t "~d is not an open claim.~%" x)))))
	(SCI3 TOP-ITEM ("otter" WH NAME) 
	      #'(lambda (xs)
		  (let* ((x (intern xs))
			 (ts (get x 'timestamp)))
		    (if (and (claimname-p x) ts)
			(if (dtype-returns-pf-p (get x 'dbtype))
			    (if (otter-res-fill-claim x
						      (remove-if-not #'(lambda (z)
									 (< (get z 'timestamp) ts))
								     *global-sigma*))
				(format t "*Otter found a refutation!*~%")
			      (format t "Otter did not find a refutation.~%"))
			  (format t "~d does not have a proof type.~%" x))
		      (format t "~d is not an open claim.~%" x)))))
	(SCI3 TOP-ITEM ("tps" WH NAME) 
	      #'(lambda (xs)
		  (let* ((x (intern xs))
			 (ts (get x 'timestamp)))
		    (if (and (claimname-p x) ts)
			(if (dtype-returns-pf-p (get x 'dbtype))
			    (if (tps-res-fill-claim x)
				(format t "*TPS found a proof!*~%")
			      (format t "TPS did not find a proof.~%"))
			  (format t "~d does not have a proof type.~%" x))
		      (format t "~d is not an open claim.~%" x)))))
	(TOP1 TOP-ITEM ("prove" WH NAME)
	      #'(lambda (xs)
		  (let* ((x (intern xs))
			 (ts (get x 'timestamp)))
		    (if (and (claimname-p x) ts)
			(if (dtype-returns-pf-p (get x 'dbtype))
			    (scip x)
			  (format t "~d does not have a proof type.~%" x))
		      (format t "~d is not an open claim.~%" x)))))
	(TOP1 TOP-ITEM ("all-claims")
	      (let ((cl (all-claims)))
		(if cl
		    (if (cdr cl)
			(progn
			  (format t "Open Claims:~%")
			  (dolist (c cl)
			    (format t "~d~%" c)))
		      (format t "Open Claim: ~d~%" (car cl)))
		  (format t "There Are No Open Claims.~%"))))

	(SCI3 TOP-ITEM ("show-ctx")
	      (progn
		(if *input1-ctx-info*
		    (dolist (xi *input1-ctx-info*)
		      (format t "~d:~d~%"
			      (car xi)
			      (output1-type-string (cadar (cadr xi)))))
		  (format t "Empty Ctx~%")
		  )))
	(SCI3 TOP-ITEM ("clear-ctx")
	      (progn
		(clear-bvars (mapcar #'car *input1-ctx-info*))
		(setq *input1-ctx-info* nil)
		(format t "Empty Ctx~%")
		))
	(SCI3 TOP-ITEM ("push-ctx")
	      (progn
		(push-input1-ctx)
		))
	(SCI3 TOP-ITEM ("pop-ctx")
	      (progn
		(if *input1-ctx-stack*
		    (progn
		      (pop-input1-ctx)
		      (if *input1-ctx-info*
			  (format t "Most Recent In Ctx:~%~d:~d~%"
				  (caar *input1-ctx-info*)
				  (output1-type-string (cadar (cadar *input1-ctx-info*))))
			(format t "Empty Ctx~%")))
		  (format t "No previous ctx~%"))))

	(SCU1 TOP-ITEM ("typeof" WH EXTRACT)
	      #'(lambda (pre-ex)
		  (multiple-value-bind
		   (e newtp info fail)
		   (extr-fill-in-blanks-1 pre-ex *input1-state* (input1-blanks-prefix *input1-ctx-info*))
		   (if (or info fail)
		       (progn
			 (format t "Could not determine a well-typed extraction term from input.~%")
			 (when fail
			   (format t "~d~%" fail))
			 (dolist (z info)
			   (when (eq (car z) 'EVAR) 
			     (let ((trm (nth 4 z))
				   (dtp (nth 5 z))
				   (etp (nth 6 z)))
			       (if (and trm dtp etp)
				   (format t "Term: ~d~%Has Type: ~d~%Expected Type: ~d~%"
					   (output1-extraction-string trm nil t)
					   (output1-type-string etp nil t)
					   (output1-type-string dtp nil t))
				 (when (nth 3 z)
				   (format t "~d" (nth 3 z))))))))
		     (if e
			 (format t "Type: ~d~%" (output1-type-string newtp (mapcar #'car *input1-ctx-info*)))
		       (format t "Could not determine an extraction term from input.~%"))))))

	(SCU1 TOP-ITEM ("justify" WH EXTRACT)
	      #'(lambda (pre-ex)
		  (multiple-value-bind
		   (e newtp info fail)
		   (extr-fill-in-blanks-1 pre-ex *input1-state* (input1-blanks-prefix *input1-ctx-info*))
		   (if (or info fail)
		       (progn
			 (format t "Could not determine a well-typed extraction term from input.~%")
			 (when fail
			   (format t "~d~%" fail))
			 (dolist (z info)
			   (when (eq (car z) 'EVAR) 
			     (let ((trm (nth 4 z))
				   (dtp (nth 5 z))
				   (etp (nth 6 z)))
			       (if (and trm dtp etp)
				   (format t "Term: ~d~%Has Type: ~d~%Expected Type: ~d~%"
					   (output1-extraction-string trm nil t)
					   (output1-type-string etp nil t)
					   (output1-type-string dtp nil t))
				 (when (nth 3 z)
				   (format t "~d" (nth 3 z))))))))
		     (if (heq newtp (prop))
			 (let* ((goaltp (pf (named-term-to-db-1 (mapcar #'car *input1-ctx-info*) e)))
				(g (quick-fill-gap (db-ctx-info *input1-ctx-info*)
						   goaltp *justify-usable* t 0 nil)))
			   (if g
			       (format t "Proof Term:~%~d~%" (output1-extraction-string 
							      (normalize (app-n-1-to-0 (length *input1-ctx-info*) (caar g)))
							      (mapcar #'car *input1-ctx-info*)
							      t))
			     (format t "Could not justify prop~%")))
		       (format t "Given extraction was not a prop~%"))))))

	(SCU1 TOP-ITEM ("use" WH NAMELIST)
	      #'(lambda (xl)
		  (setq xl (mapcar #'(lambda (x)
				       (if (stringp x) (intern x) x)) xl))
		  (if (member '|all| xl)
		      (setq *justify-usable* *global-sigma*)
		    (if (member '|none| xl)
			(setq *justify-usable* nil)
		    (progn
		      (setq *justify-usable* nil)
		      (dolist (x xl)
			(cond ((eq x '|fo|)
			       (setq *justify-usable*
				     (union (remove-if-not #'(lambda (co)
							       (and (not (get co 'auto-gen)) (or (get co 'fo-unif-type) (get co 'fo-type))))
							   *global-sigma*)
					    *justify-usable*)))
			      ((eq x '|defns|)
			       (setq *justify-usable*
				     (union (remove-if-not #'(lambda (co)
							       (get co 'auto-gen))
							   *global-sigma*)
					    *justify-usable*)))
			      ((eq x '|so|)
			       (setq *justify-usable*
				     (union (remove-if #'(lambda (co)
							   (or (get co 'auto-gen) (get co 'fo-unif-type) (get co 'fo-type)))
						       *global-sigma*)
					    *justify-usable*)))
			      ((and (get x 'dbtype) (or (dtype-returns-dclass-p (get x 'dbtype))
							(dtype-returns-pf-p (get x 'dbtype))))
			       (push x *justify-usable*)
			       )
			      (t (format t "Ignoring ~d~%" x)))))))
		  (if *justify-usable*
		      (format t "Reset usable~%")
		    (format t "WARNING: usable empty!~%"))))

	(SCU1 TOP-ITEM ("unif+")
	      (progn
		  (format t "~d~%" (incf *preunify-msv-goal*))
		  (format t "~d~%" (incf *preunify-msv-hence*))
		  (format t "~d~%" (incf *preunify-msv-supp*))))
	(SCU1 TOP-ITEM ("unif-")
	      (progn
		  (format t "~d~%" (decf *preunify-msv-goal*))
		  (format t "~d~%" (decf *preunify-msv-hence*))
		  (format t "~d~%" (decf *preunify-msv-supp*))))
						 
		      
		  

;	(LR1 LINGRULE ("(@" WH LINGRULEL ")") 
;	     #'(lambda (l) (apply #'@ l)))
;	(LR2 LINGRULE ("\"" LINGSTRING "\"") ?)
;	(LR3 LINGRULE (LINGRULE "::" ?) ?)

	(GGCP GENGRAMCAT ("PROOF") PROOF)
	(GGCMO GENGRAMCAT ("MATHOBJ") MATHOBJ)
	(GGCO GENGRAMCAT ("OBJ") OBJ)
	(GGCMP GENGRAMCAT ("MATHPROP") MATHPROP)
	(GGCP GENGRAMCAT ("PROP") PROP)
	(GGCA GENGRAMCAT ("ASSERTION") ASSERTION)
	(GGCD GENGRAMCAT ("DISCOURSE") DISCOURSE)

	(COMM1 COMMAND ("q.") (QUIT-COMMAND))
	(COMM2 COMMAND ("prove" WH EXTRACT ".") 
	       #'(lambda (x) (prove-command x)))
	(COMM3 COMMAND ("let" WH NAME ".")
	       #'(lambda (x) (let-command x)))
	(COMM4 COMMAND ("let" WH NAME ":" DTYPE0 ".")
	       #'(lambda (x y) (let-command x y)))
	(COMM5 COMMAND ("assume" WH EXTRACT ".")
	       #'(lambda (x) (assume-command x)))

	(COMMSTAT COMMAND ("status.") (print-status))
	(PCOMMSTAT PFCOMMAND ("status.") '(print-status))

	(PCOMMSTAT PFCOMMAND ("help") '(print-tutor-help))
	(PCOMMSTAT PFCOMMAND ("help.") '(print-tutor-help))

	(PCOMM1 PFCOMMAND ("qed") '(QED-PFCOMMAND))
	(PCOMM1 PFCOMMAND ("done") '(QED-PFCOMMAND))
	(PCOMM1 PFCOMMAND ("qed.") '(QED-PFCOMMAND))
	(PCOMM1 PFCOMMAND ("done.") '(QED-PFCOMMAND))
	(PCOMM1 PFCOMMAND ("undo.") '(UNDO-PFCOMMAND))
	(PCOMM1 PFCOMMAND ("undo") '(UNDO-PFCOMMAND))
	(PCOMM2 PFCOMMAND ("i" WH "give" WH "up") '(QUIT-PFCOMMAND))
	(PCOMM2 PFCOMMAND ("i" WH "give" WH "up.") '(QUIT-PFCOMMAND))
	(PCOMM3 PFCOMMAND ("claim" WH EXTRACT)
	       #'(lambda (x) (list 'claim-pfcommand x)))
	(PCOMM3 PFCOMMAND ("claim" WH EXTRACT ".")
	       #'(lambda (x) (list 'claim-pfcommand x)))
	(PCOMM3 PFCOMMAND ("let" WH NAMELIST ".")
	       #'(lambda (xl) (list 'let-pfcommand (mapcar #'intern xl))))
	(PCOMM4 PFCOMMAND ("let" WH NAMELIST ":" DTYPE0 ".")
	       #'(lambda (xl y) (list 'let-pfcommand (mapcar #'intern xl) y)))
	(PCOMM5 PFCOMMAND ("assume" WH EXTRACT ".")
	       #'(lambda (x) (list 'assume-pfcommand x)))
	(PCOMM2 PFCOMMAND ("willshow" WH EXTRACT ".") 
	       #'(lambda (x) (list 'subgoal-pfcommand x)))
;	(PCOMM7 PFCOMMAND ("exists" WH NAME ".") #'(lambda (x) (list 'EXISTS-PFCOMMAND x)))
;	(PCOMM7 PFCOMMAND ("exists" WH NAME WH EXTRACT ".") #'(lambda (x y) (list 'EXISTS-PFCOMMAND x y)))
	(PCOMM7 PFCOMMAND ("exists" WH NAME ":" EXTRACT WH "." WH EXTRACT ".") #'(lambda (x y z) (list 'EXISTS-PFCOMMAND x y z)))
	(PCOMM6 PFCOMMAND ("cases.") '(CASES-PFCOMMAND))
	(PCOMM7 PFCOMMAND ("cases" WH EXTRACT ".") #'(lambda (x) (list 'CASES-PFCOMMAND x)))
	(PCOMM8 PFCOMMAND ("contradiction.") (list 'CONTRADICTION-PFCOMMAND))
	(PCOMM9 PFCOMMAND ("case" WH SMALLNUM ".") #'(lambda (i) (list 'CASE-PFCOMMAND i)))
	(PCOMM10 PFCOMMAND ("case" WH SMALLNUM WH EXTRACT ".") #'(lambda (i x) (list 'CASE-PFCOMMAND i x)))
	(PCOMM11 PFCOMMAND ("close" WH "case.") '(CLOSE-CASE-PFCOMMAND))
	(PCOMM12 PFCOMMAND ("hence" WH EXTRACT ".") #'(lambda (x) (list 'HENCE-PFCOMMAND x)))
	(PCOMM13 PFCOMMAND ("clearly" WH EXTRACT ".") #'(lambda (x) (list 'CLEARLY-PFCOMMAND x)))
	(PCOMM14 PFCOMMAND ("by" WH EXTRACTL "," WH "we" WH "have" WH EXTRACT ".")
		 #'(lambda (refs x) (list 'BY-PFCOMMAND refs x)))
	(PCOMM14 PFCOMMAND ("since" WH EXTRACTL "," WH "we" WH "have" WH EXTRACT ".")
		 #'(lambda (pre-conds x) (list 'SINCE-PFCOMMAND pre-conds x)))
	(PCOMM15 PFCOMMAND ("alts" WH PFCOMMANDL ".") ; this doesn't yet work
		 #'(lambda (pcl) (list 'alt-pfcommands pcl)))

	(PCOMML1 PFCOMMANDL ("[" PFCOMMAND "]") #'list)
	(PCOMML2 PFCOMMANDL ("[" PFCOMMAND "]" WH PFCOMMANDL) #'cons)
	(EL1 EXTRACTL (EXTRACT) #'list)
	(EL2 EXTRACTL (EXTRACT "," WH EXTRACTL) #'cons)
	(EL2 EXTRACTL (EXTRACT "," EXTRACTL) #'cons)
	(SN1 SMALLNUM ("1") 1)
	(SN2 SMALLNUM ("2") 2)
	(SN3 SMALLNUM ("3") 3)
	(SN4 SMALLNUM ("4") 4)
	(SN5 SMALLNUM ("5") 5)
	(SN6 SMALLNUM ("6") 6)
	(SN7 SMALLNUM ("7") 7)
	(SN8 SMALLNUM ("8") 8)
	(SN9 SMALLNUM ("9") 9)

	(DTYPE2A DTYPE2 (DTYPE1)
		 #'identity
		 )
	(DTYPE2B DTYPE2 ("{" NAME ":" DTYPE1 "}" DTYPE2)
		 #'(lambda (x domtp codtp)
		     (list 'PI x domtp codtp)))
	(DTYPE2Bw DTYPE2 ("{" NAME ":" DTYPE1 "}" WH DTYPE2)
		 #'(lambda (x domtp codtp)
		     (list 'PI x domtp codtp)))
	(DTYPE2C DTYPE2 (DTYPE1 "->" DTYPE2)
		 #'(lambda (domtp codtp)
		     (list domtp '-> codtp)))
;	(DTYPE2C DTYPE2 ("(" DTYPE1 "->" DTYPE2 ")")
;		 #'(lambda (domtp codtp)
;		     (cons 'darr (cons domtp codtp))))
	(DTYPE2Cwn DTYPE2 (DTYPE1 WH "->" DTYPE2)
		 #'(lambda (domtp codtp)
		     (list domtp '-> codtp)))
	(DTYPE2Cnw DTYPE2 (DTYPE1 "->" WH DTYPE2)
		 #'(lambda (domtp codtp)
		     (list domtp '-> codtp)))
	(DTYPE2Cww DTYPE2 (DTYPE1 WH "->" WH DTYPE2)
		 #'(lambda (domtp codtp)
		     (list domtp '-> codtp)))
	(DTYPE2Cp DTYPE2 ("(" DTYPE1 ")" "->" DTYPE2)
		  #'(lambda (domtp codtp)
		     (list domtp '-> codtp)))
	(DTYPE2Cpr DTYPE2 (DTYPE1 "->" "(" DTYPE2 ")")
		  #'(lambda (domtp codtp)
		     (list domtp '-> codtp)))
	(DTYPE2Cpwn DTYPE2 ("(" DTYPE1 ")" WH "->" DTYPE2)
		 #'(lambda (domtp codtp)
		     (list domtp '-> codtp)))
	(DTYPE2Cpnw DTYPE2 ("(" DTYPE1 ")" "->" WH DTYPE2)
		 #'(lambda (domtp codtp)
		     (list domtp '-> codtp)))
	(DTYPE2Cpww DTYPE2 ("(" DTYPE1 ")" WH "->" WH DTYPE2)
		 #'(lambda (domtp codtp)
		     (list domtp '-> codtp)))
	(DTYPE1A DTYPE1 (DTYPE0)
		 #'identity
		 )
	(DTYPE1B DTYPE1 ("{" NAME ":" DTYPE0 "}" DTYPE1)
		 #'(lambda (x domtp codtp)
		     (list 'PI x domtp codtp)))
;	(DTYPE1B DTYPE1 ("({" NAME ":" DTYPE0 "}" DTYPE1 ")")
;		 #'(lambda (x domtp codtp)
;		     (cons 'dpi (cons (intern x) (cons domtp codtp)))))
	(DTYPE1Bw DTYPE1 ("{" NAME ":" DTYPE0 "}" WH DTYPE1)
		 #'(lambda (x domtp codtp)
		     (list 'PI x domtp codtp)))
	(DTYPE1C DTYPE1 (DTYPE0 "->" DTYPE1)
		 #'(lambda (domtp codtp)
		     (list domtp '-> codtp)))
;	(DTYPE1C DTYPE1 ("(" DTYPE0 "->" DTYPE1 ")")
;		 #'(lambda (domtp codtp)
;		     (cons 'darr (cons domtp codtp))))
	(DTYPE1Cwn DTYPE1 (DTYPE0 WH "->" DTYPE1)
		 #'(lambda (domtp codtp)
		     (list domtp '-> codtp)))
	(DTYPE1Cnw DTYPE1 (DTYPE0 "->" WH DTYPE1)
		   #'(lambda (domtp codtp)
		     (list domtp '-> codtp)))
	(DTYPE1Cww DTYPE1 (DTYPE0 WH "->" WH DTYPE1)
		 #'(lambda (domtp codtp)
		     (list domtp '-> codtp)))
	(DTYPE0A DTYPE0 ("prop") 'PROP)
	(DTYPE0B DTYPE0 ("obj") 'OBJ)
	(DTYPE0B DTYPE0 ("set") 'OBJ)
	(DTYPE0C DTYPE0 ("|-" WH EXTRACT)
		 #'(lambda (prop) (list 'PF prop)))
	(DTYPE0C DTYPE0 (EXTRACT) ; preterms code tries to make this a type, class or pf
		 #'(lambda (pred) pred))
;	(DTYPE0D DTYPE0 (EXTRACT) ; default to turning prop to pf type
;		 #'(lambda (prop) (list 'PF prop)))

	(EXTR1 EXTRACT (EXTRACT2) #'identity)
	(EXTRP EXTRACT ("(" EXTRACT2 ")") #'identity)

	(EXTR1 EXTRACT2 (NAME) #'(lambda (x) x))
	(EXTR2 EXTRACT2 (NAME WH NORMALL) #'(lambda (x y)
					      (cons x y)))

	(BOP1 BINOP ("!=") '!=)
	(BOP1 BINOP ("==") '==)
	(BOP1 BINOP ("=>") '=>)
	(BOP1 BINOP ("<=>") '<=>)
	(BOP1 BINOP ("&") '&)
	(BOP1 BINOP ("|") 'OR)
	(BOP1 BINOP ("::") 'IN)
	(BOP1 BINOP ("<=") '<=) ; can be redefined by user now, subset default
	(BOP1 BINOP (";") '|;|)
	(BOP1 BINOP ("\\cup") 'CUP)
	(BOP1 BINOP ("\\cap") 'CAP)
	(BOP1 BINOP ("\\times") 'TIMES)

	(BOP1 UBINOP ("@") '@)
	(BOP1 UBINOP ("@@") '@@)
	(BOP1 UBINOP ("+") '+)
	(BOP1 UBINOP ("++") '++)
	(BOP1 UBINOP ("-") '-)
	(BOP1 UBINOP ("--") '--)
	(BOP1 UBINOP ("/") '/)
	(BOP1 UBINOP ("//") '//)
	(BOP1 UBINOP ("*") '*)
	(BOP1 UBINOP ("**") '**)
	(BOP1 UBINOP ("<") '<)
	(BOP1 UBINOP (">") '>)

	(EXTRBOP EXTRACT2 (EXTRACT BINOP EXTRACT)
		 #'(lambda (x bop y)
		     (list x bop y)))
	(EXTRBOP EXTRACT2 (EXTRACT WH BINOP WH EXTRACT)
		 #'(lambda (x bop y)
		     (list x bop y)))
	(EXTRBOP EXTRACT2 (EXTRACT WH UBINOP WH EXTRACT) ; force whitespace for ubinop's
		 #'(lambda (x ubop y)
		     (list x ubop y)))
	(EXTRNOT EXTRACT2 ("~" EXTRACT)
		 #'(lambda (x)
		     (list "not" x)))
	(EXTREX EXTRACT2 ("exists1" WH NAMELIST ":" EXTRACT WH "." WH EXTRACT)
		#'(lambda (nl bd body)
		    (list 'EXISTS1 nl bd body)))
	(EXTREX EXTRACT2 ("exists" WH NAMELIST ":" EXTRACT WH "." WH EXTRACT)
		#'(lambda (nl bd body)
		    (list 'EXISTS nl bd body)))
	(EXTRALL EXTRACT2 ("forall" WH NAMELIST ":" EXTRACT WH "." WH EXTRACT)
		#'(lambda (nl bd body)
		    (list 'FORALL nl bd body)))
	(EXTRKP EXTRACT2 ("<<" EXTRACT "," EXTRACTL ">>")
		#'(lambda (x y)
		    (let ((ret x))
		      (do ((yl y (cdr yl)))
			  ((null (cdr yl))
			   (list "kpair" ret (car yl)))
			  (setq ret (list "kpair" ret (car yl)))))))

	(NORMALL2 NORMALL (NORMAL WH NORMALL) #'cons)
	(NORMALL1 NORMALL (NORMAL) #'list)

	(EXTRACTUND1 EXTRACT ("_") '_)
	(EXTRACTUND2 EXTRACT ("?") '?)
	(SETEXTR EXTRACT ("{" NAME "|" EXTRACT "}")
		 #'(lambda (x y) (list 'CLASSOF x y)))
	(SETEXTR EXTRACT ("{" NAME ":" EXTRACT "|" EXTRACT "}")
		 #'(lambda (x y z) (list 'SETOF x y z)))
	(PSETEXTR EXTRACT ("{<<" NAME "," NAME ">>:" EXTRACT WH "\\times" WH EXTRACT "|" EXTRACT "}")
		  #'(lambda (x y set1 set2 body) (list 'SETOFPAIRS x y set1 set2 body)))
	(PSETEXTR EXTRACT ("{<<" NAME "," NAME ">>:(" EXTRACT WH "\\times" WH EXTRACT ")|" EXTRACT "}")
		  #'(lambda (x y set1 set2 body) (list 'SETOFPAIRS x y set1 set2 body)))
	(SETENUM EXTRACT ("{" EXTRACTL "}")
		 #'(lambda (x) (cons 'SETENUM x)))
	(SETENUM EXTRACT ("{}") "emptyset")

	(NORMAL1 NORMAL (EXTRACT) #'identity)
	(NORMAL2 NORMAL ("(\\" NAMELIST "." EXTRACT ")") 
		 #'(lambda (lams extr)
		     (list 'LAM lams extr)))
	(NORMAL2p NORMAL ("(\\" NAMELIST ".<" EXTRACT "," EXTRACT ">)") 
		 #'(lambda (lams extr1 extr2)
		     (list 'LAM lams (list 'PAIR extr1 extr2))))
	(NORMAL6 NORMAL ("<" EXTRACT "," EXTRACT ">")
		 #'(lambda (x y) (list 'PAIR x y))) ; only pairs of atomic type, hence extraction.
	
	(NA1 NEWAPP (NAME) #'(lambda (x)
				 (list x)))
	(NA2 NEWAPP ("(" NAME WH NAMELIST ")") #'cons)

	(NL1 NAMELIST (NAME) #'list)
	(NL2 NAMELIST (NAME WH NAMELIST) #'cons)

;	(NL1 NAMECLIST (NAME) #'list)
;	(NL2 NAMECLIST (NAME "," NAMECLIST) #'cons)
;	(NL3 NAMECLIST (NAME "," WH NAMECLIST) #'cons)

	(NAME1 NAME (NAMEBEGCHAR NAMEREST) #'(lambda (x y) (format nil "~d~d" x y)))

	(NAMERnil NAMEREST nil "")
	(NAMERcons NAMEREST (NAMECHAR NAMEREST) #'(lambda (x y) (format nil "~d~d" x y)))

	(NUM1 NUMBER (DIGIT) #'identity)
	(NUM2 NUMBER (NUMBER DIGIT) #'(lambda (x y) (+ (* 10 x) y)))
	(DIGIT0 DIGIT ("0") 0)
	(DIGIT1 DIGIT ("1") 1)
	(DIGIT2 DIGIT ("2") 2)
	(DIGIT3 DIGIT ("3") 3)
	(DIGIT4 DIGIT ("4") 4)
	(DIGIT5 DIGIT ("5") 5)
	(DIGIT6 DIGIT ("6") 6)
	(DIGIT7 DIGIT ("7") 7)
	(DIGIT8 DIGIT ("8") 8)
	(DIGIT9 DIGIT ("9") 9)

	(NAMECHAR45 NAMECHAR ("-") #\-)
	(NAMECHAR43 NAMECHAR ("+") #\+)
	(NAMECHAR47 NAMECHAR ("/") #\/)
	(NAMECHAR48 NAMECHAR ("0") #\0)
	(NAMECHAR49 NAMECHAR ("1") #\1)
	(NAMECHAR50 NAMECHAR ("2") #\2)
	(NAMECHAR51 NAMECHAR ("3") #\3)
	(NAMECHAR52 NAMECHAR ("4") #\4)
	(NAMECHAR53 NAMECHAR ("5") #\5)
	(NAMECHAR54 NAMECHAR ("6") #\6)
	(NAMECHAR55 NAMECHAR ("7") #\7)
	(NAMECHAR56 NAMECHAR ("8") #\8)
	(NAMECHAR57 NAMECHAR ("9") #\9)
	(NAMECHAR65 NAMECHAR ("A") #\A)
	(NAMECHAR66 NAMECHAR ("B") #\B)
	(NAMECHAR67 NAMECHAR ("C") #\C)
	(NAMECHAR68 NAMECHAR ("D") #\D)
	(NAMECHAR69 NAMECHAR ("E") #\E)
	(NAMECHAR70 NAMECHAR ("F") #\F)
	(NAMECHAR71 NAMECHAR ("G") #\G)
	(NAMECHAR72 NAMECHAR ("H") #\H)
	(NAMECHAR73 NAMECHAR ("I") #\I)
	(NAMECHAR74 NAMECHAR ("J") #\J)
	(NAMECHAR75 NAMECHAR ("K") #\K)
	(NAMECHAR76 NAMECHAR ("L") #\L)
	(NAMECHAR77 NAMECHAR ("M") #\M)
	(NAMECHAR78 NAMECHAR ("N") #\N)
	(NAMECHAR79 NAMECHAR ("O") #\O)
	(NAMECHAR80 NAMECHAR ("P") #\P)
	(NAMECHAR81 NAMECHAR ("Q") #\Q)
	(NAMECHAR82 NAMECHAR ("R") #\R)
	(NAMECHAR83 NAMECHAR ("S") #\S)
	(NAMECHAR84 NAMECHAR ("T") #\T)
	(NAMECHAR85 NAMECHAR ("U") #\U)
	(NAMECHAR86 NAMECHAR ("V") #\V)
	(NAMECHAR87 NAMECHAR ("W") #\W)
	(NAMECHAR88 NAMECHAR ("X") #\X)
	(NAMECHAR89 NAMECHAR ("Y") #\Y)
	(NAMECHAR90 NAMECHAR ("Z") #\Z)
	(NAMECHAR94 NAMECHAR ("^") #\^)
	(NAMECHAR95 NAMECHAR ("_") #\_)
	(NAMECHAR97 NAMECHAR ("a") #\a)
	(NAMECHAR98 NAMECHAR ("b") #\b)
	(NAMECHAR99 NAMECHAR ("c") #\c)
	(NAMECHAR100 NAMECHAR  ("d") #\d)
	(NAMECHAR101 NAMECHAR  ("e") #\e)
	(NAMECHAR102 NAMECHAR  ("f") #\f)
	(NAMECHAR103 NAMECHAR  ("g") #\g)
	(NAMECHAR104 NAMECHAR  ("h") #\h)
	(NAMECHAR105 NAMECHAR  ("i") #\i)
	(NAMECHAR106 NAMECHAR  ("j") #\j)
	(NAMECHAR107 NAMECHAR ("k") #\k)
	(NAMECHAR108 NAMECHAR ("l") #\l)
	(NAMECHAR109 NAMECHAR ("m") #\m)
	(NAMECHAR110 NAMECHAR ("n") #\n)
	(NAMECHAR111 NAMECHAR ("o") #\o)
	(NAMECHAR112 NAMECHAR ("p") #\p)
	(NAMECHAR113 NAMECHAR ("q") #\q)
	(NAMECHAR114 NAMECHAR ("r") #\r)
	(NAMECHAR115 NAMECHAR ("s") #\s)
	(NAMECHAR116 NAMECHAR ("t") #\t)
	(NAMECHAR117 NAMECHAR ("u") #\u)
	(NAMECHAR118 NAMECHAR ("v") #\v)
	(NAMECHAR119 NAMECHAR ("w") #\w)
	(NAMECHAR120 NAMECHAR ("x") #\x)
	(NAMECHAR121 NAMECHAR ("y") #\y)
	(NAMECHAR122 NAMECHAR ("z") #\z)
	(NAMECHAR126 NAMECHAR ("~") #\~)
	(NAMECHAR126 NAMECHAR ("#") #\#)

	(NAMEBEGCHAR48 NAMEBEGCHAR ("0") #\0)
	(NAMEBEGCHAR49 NAMEBEGCHAR ("1") #\1)
	(NAMEBEGCHAR50 NAMEBEGCHAR ("2") #\2)
	(NAMEBEGCHAR51 NAMEBEGCHAR ("3") #\3)
	(NAMEBEGCHAR52 NAMEBEGCHAR ("4") #\4)
	(NAMEBEGCHAR53 NAMEBEGCHAR ("5") #\5)
	(NAMEBEGCHAR54 NAMEBEGCHAR ("6") #\6)
	(NAMEBEGCHAR55 NAMEBEGCHAR ("7") #\7)
	(NAMEBEGCHAR56 NAMEBEGCHAR ("8") #\8)
	(NAMEBEGCHAR57 NAMEBEGCHAR ("9") #\9)
	(NAMEBEGCHAR65 NAMEBEGCHAR ("A") #\A)
	(NAMEBEGCHAR66 NAMEBEGCHAR ("B") #\B)
	(NAMEBEGCHAR67 NAMEBEGCHAR ("C") #\C)
	(NAMEBEGCHAR68 NAMEBEGCHAR ("D") #\D)
	(NAMEBEGCHAR69 NAMEBEGCHAR ("E") #\E)
	(NAMEBEGCHAR70 NAMEBEGCHAR ("F") #\F)
	(NAMEBEGCHAR71 NAMEBEGCHAR ("G") #\G)
	(NAMEBEGCHAR72 NAMEBEGCHAR ("H") #\H)
	(NAMEBEGCHAR73 NAMEBEGCHAR ("I") #\I)
	(NAMEBEGCHAR74 NAMEBEGCHAR ("J") #\J)
	(NAMEBEGCHAR75 NAMEBEGCHAR ("K") #\K)
	(NAMEBEGCHAR76 NAMEBEGCHAR ("L") #\L)
	(NAMEBEGCHAR77 NAMEBEGCHAR ("M") #\M)
	(NAMEBEGCHAR78 NAMEBEGCHAR ("N") #\N)
	(NAMEBEGCHAR79 NAMEBEGCHAR ("O") #\O)
	(NAMEBEGCHAR80 NAMEBEGCHAR ("P") #\P)
	(NAMEBEGCHAR81 NAMEBEGCHAR ("Q") #\Q)
	(NAMEBEGCHAR82 NAMEBEGCHAR ("R") #\R)
	(NAMEBEGCHAR83 NAMEBEGCHAR ("S") #\S)
	(NAMEBEGCHAR84 NAMEBEGCHAR ("T") #\T)
	(NAMEBEGCHAR85 NAMEBEGCHAR ("U") #\U)
	(NAMEBEGCHAR86 NAMEBEGCHAR ("V") #\V)
	(NAMEBEGCHAR87 NAMEBEGCHAR ("W") #\W)
	(NAMEBEGCHAR88 NAMEBEGCHAR ("X") #\X)
	(NAMEBEGCHAR89 NAMEBEGCHAR ("Y") #\Y)
	(NAMEBEGCHAR90 NAMEBEGCHAR ("Z") #\Z)
	(NAMEBEGCHAR97 NAMEBEGCHAR ("a") #\a)
	(NAMEBEGCHAR98 NAMEBEGCHAR ("b") #\b)
	(NAMEBEGCHAR99 NAMEBEGCHAR ("c") #\c)
	(NAMEBEGCHAR100 NAMEBEGCHAR ("d") #\d)
	(NAMEBEGCHAR101 NAMEBEGCHAR ("e") #\e)
	(NAMEBEGCHAR102 NAMEBEGCHAR ("f") #\f)
	(NAMEBEGCHAR103 NAMEBEGCHAR ("g") #\g)
	(NAMEBEGCHAR104 NAMEBEGCHAR ("h") #\h)
	(NAMEBEGCHAR105 NAMEBEGCHAR ("i") #\i)
	(NAMEBEGCHAR106 NAMEBEGCHAR ("j") #\j)
	(NAMEBEGCHAR107 NAMEBEGCHAR ("k") #\k)
	(NAMEBEGCHAR108 NAMEBEGCHAR ("l") #\l)
	(NAMEBEGCHAR109 NAMEBEGCHAR ("m") #\m)
	(NAMEBEGCHAR110 NAMEBEGCHAR ("n") #\n)
	(NAMEBEGCHAR111 NAMEBEGCHAR ("o") #\o)
	(NAMEBEGCHAR112 NAMEBEGCHAR ("p") #\p)
	(NAMEBEGCHAR113 NAMEBEGCHAR ("q") #\q)
	(NAMEBEGCHAR114 NAMEBEGCHAR ("r") #\r)
	(NAMEBEGCHAR115 NAMEBEGCHAR ("s") #\s)
	(NAMEBEGCHAR116 NAMEBEGCHAR ("t") #\t)
	(NAMEBEGCHAR117 NAMEBEGCHAR ("u") #\u)
	(NAMEBEGCHAR118 NAMEBEGCHAR ("v") #\v)
	(NAMEBEGCHAR119 NAMEBEGCHAR ("w") #\w)
	(NAMEBEGCHAR120 NAMEBEGCHAR ("x") #\x)
	(NAMEBEGCHAR121 NAMEBEGCHAR ("y") #\y)
	(NAMEBEGCHAR122 NAMEBEGCHAR ("z") #\z)

	(STRING1 STRING NIL "")
	(STRING2 STRING (NAMECHAR STRING) 
		 #'(lambda (ch str)
		     (format nil "~d~d" ch str)))
	(STRING3 STRING ("." STRING) 
		 #'(lambda (str)
		     (format nil ".~d" str)))
	(STRING4 STRING (WH STRING) 
		 #'(lambda (str)
		     (format nil " ~d" str)))

	(STRINGL1 QSTRINGL ("\"" STRING "\"") #'list)
	(STRINGL2 QSTRINGL ("\"" STRING "\"" "," WH QSTRINGL) #'cons)
	))

(setq input1-tol-grammar (grules-to-grammar input1-tol-grules))

(defun compile-input1 (filename)
  (declare (special grammar))
  (let ((save-grammar grammar))
    (initialize-input1-globals)
    (setq grammar input1-tol-grammar)
    (compile-input1-real filename)
    (setq grammar save-grammar)
    (clear-bvars (mapcar #'car *input1-ctx-info*))
    ))

(defvar *compile-input1-out* nil)

(defun compile-input1-real (filename)
  (setq *input1-ctx-info* nil)
  (let ((outfilename nil))
    (setq outfilename (format nil "~d.pamela" filename))
    (if (s-probe-file (format nil "~d.pam" filename))
	(setq filename (format nil "~d.pam" filename))
      (fail "Could not find pam file" filename))
    (let ((s (open filename :direction :input)))
      (setq *compile-input1-out* (open outfilename :direction :output :if-exists :supersede))
      (let ((*last-char* (read-char s nil nil))
	    (*position* 0))
	(declare (special *last-char* *position*))
	(let ((*last-token* (read-token s))
	      (failed nil)
	      (failinfo nil))
	  (declare (special *last-token*))
	  (do ((i
		(parse-stream s 'DOCUMENTITEM grammar 0)
		(parse-stream s 'DOCUMENTITEM grammar 0)))
	      ((null i)
	       (close *compile-input1-out*)
	       (close s))
	      (multiple-value-setq
	       (grammar failed failinfo)
	       (process-parsed-input (cadr i) grammar))
	      (when failed
		(format t "Failed to process ~d~%" (car i))
		(dolist (x failinfo)
		  (format t "~d~%" x))
		(fail ""))
	      ))))))

  

(defun readinput1l (filename)
  (initialize-input1-globals)
  (readinput1l-real filename)
  (clear-bvars (mapcar #'car *input1-ctx-info*))
  )

; Syntax:
; Static Commands:
; (LET <string> <dtype>)
; (CONST <newapp> <dtype>)
; (ABBREV <newapp> <dtype> <norm>)
; (ABBREVE <newapp> <extr>)
; (CLAIM2ABBREV <newapp> <norm>)
; (COERCION <string> <extr>)
; (NOTATION-INFIX <ubinop> <extr>)
; (NOTATION <string> <extr>)
; (LOAD <string>)
; (LOADL <string>)
; (AUTHOR <string>)
; (AUTHORS <string> ... <string>)
; Interactive Commands:
; (HELP)
; (HELP <string>)
; (TYPEOF <extr>)
; (JUSTIFY <extr>)
; (USE <string> ... <string>) ; special cases of strings: all, none, fo, defns, so
; (PROVE <string>)
; (ALL-CLAIMS)
; (SHOW-CTX)
; (CLEAR-CTX)
; (PUSH-CTX)
; (POP-CTX)
; (UNIF+)
; (UNIF-)
; (PROOFREAD <string> <newapp>)
; (TUTOR-STUDENT-USABLE <string> ... <string>)
; (TUTOR-ONLY-USABLE <string> ... <string>)


; <newapp>:
; (<string> ... <string>)

; <dtype>:
; (PI <string> <dtype> <dtype>)
; (<dtype> -> <dtype>)
; (PF <extr>)
; PROP
; OBJ
; <extr>

; <norm>:
; (LAM <stringlist> (PAIR <extr> <extr>))
; (LAM <stringlist> <extr>)
; (PAIR <extr> <extr>)
; <extr>

; <extr>:
; <string>
; <symbol>
; (<extr> <binop> <extr>)
; (<binder> <stringlist> <extr> <extr>)
; (SETOF <string> <extr> <extr>)
; (SETOFPAIRS <string> <string> <extr> <extr> <extr>)
; (CLASSOF <string> <extr>)
; (SETENUM <extr> ... <extr>)
; (<string|symbol> <norm> ... <norm>)

; <binop> : (see input1l-binop-p)
; <binder> : FORALL|EXISTS|EXISTS1
(defun readinput1l-real (filename)
  (setq *input1-ctx-info* nil)
  (unless (s-probe-file filename)
    (if (s-probe-file (format nil "~d.pamela" filename))
	(setq filename (format nil "~d.pamela" filename))
      (fail "Could not find pamela file" filename)))
  (let ((s (open filename :direction :input)))
    (do ((r (read s nil nil) (read s nil nil)))
	((null r)
	 (close s))
	(when (> *verbose* 50)
	  (format t "Read ~S~%" r))
	(multiple-value-bind
	 (ok failinfo)
	 (input1l-execute r)
	 (unless ok
	   (format t "Problem: ~d~%" failinfo)
;	   (break)
	   )))))

(defun input1l-execute (r)
  (if (consp r)
      (case (car r)
	    (LET (input1-newvar (cadr r) (input1l-predtype (caddr r))))
	    (CONST (input1-newconst (input1l-newapp (cadr r)) (input1l-predtype (caddr r))))
	    (CLAIM (input1-newclaim (input1l-newapp (cadr r)) (input1l-predtype (caddr r))))
	    (ABBREV (input1-newabbrev (input1l-newapp (cadr r)) (input1l-predtype (caddr r))
				      (input1l-prenorm (cadddr r))))
	    (ABBREVE (input1-newabbrev-extr (input1l-newapp (cadr r)) (input1l-preextr (caddr r))))
	    (CLAIM2ABBREV (input1-claim2abbrev (input1l-newapp (cadr r)) (input1l-prenorm (caddr r))))
	    (COERCION (create-input1-coercion (input1l-preextr (cadr r))))
	    (NOTATION-INFIX
	     (let ((op (input1l-ubinop-var (cadr r)))
		   (defn (input1l-preextr (caddr r))))
	       (unless op
		 (fail "NOTATION-INFIX not given a user-definable infix operator"))
	       (let ((fn (if (consp defn)
			     #'(lambda (x y)
				 (append defn (list x y)))
			   #'(lambda (x y)
			       (list defn x y)))))
		 (set op fn))))
	    (NOTATION
	     (let ((e (input1l-preextr (caddr r))))
	       (setf (get (input1l-name (cadr r)) 'notation)
		     (if (consp e) e (list e)))))
	    (LOAD
	     (let ((filename (cadr r)))
	       (record-input1-state)
	       (when (> *verbose* 1)
		 (format t "Loading ~d~%" filename))
	       (readinput1l-real filename)))
	    (LOADL
	     (let ((filename (cadr r)))
	       (record-input1-state)
	       (setq filename (format nil "~d.lisp" filename))
	       (when (> *verbose* 1)
		 (format t "Loading Lisp ~d~%" filename))
	       (s-load filename)))
	    ((AUTHOR AUTHORS) (set-authors (cdr r)))
	    ; the remaining cases should only be invoked interactively
	    (HELP
	     (if (cadr r)
		 (print-help-name (input1l-name (cadr r)))
	       (print-help-top)
	       )
	     t)
	    (VAMPIRE
	     (let* ((x (input1l-name (cadr r)))
		    (ts (get x 'timestamp)))
	       (if (and (claimname-p x) ts)
		   (if (dtype-returns-pf-p (get x 'dbtype))
		       (if (vampire-res-fill-claim x
						   (remove-if-not #'(lambda (z)
								      (< (get z 'timestamp) ts))
								  *global-sigma*))
			   (progn
			     (scu-out 'VAMPIRE-SUCCEEDED)
			     (format t "*Vampire found a refutation!*~%"))
			 (progn
			   (scu-out 'VAMPIRE-FAILED)
			   (format t "Vampire did not find a refutation.~%")))
		     (progn
		       (scu-out 'NOT-A-PFCLAIM)
		       (format t "~d does not have a proof type.~%" x)))
		 (progn
		   (scu-out 'NOT-A-PFCLAIM)
		   (format t "~d is not an open claim.~%" x)))
	       t))
	    (INPUT-SIG-AGENT
	     (let ((mach (cadr r))
		   (port (caddr r))
		   (info (nth 3 r)))
	       (input-sig-agent
		mach
		port
		info)
	       t))
	    (OUTPUT-SIG-AGENT
	     (let ((mach (cadr r))
		   (port (caddr r))
		   (info (cadddr r))
		   (beg (or (nth 4 r) 0))
		   (end (or (nth 5 r) *timestamp*)))
	       (output-sig-agent
		mach port info beg end)
	       t))
	    (REMOVE-FILL-GAP-AGENT
	     (let ((name (cadr r)))
	       (remove-external-fill-gap-agent
		(input1l-name name))
	       t))
	    (ADD-FILL-GAP-AGENT
	     (let ((name (cadr r))
		   (mach (caddr r))
		   (port (cadddr r)))
	       (add-external-fill-gap-agent
		(input1l-name name)
		mach
		port)
	       t))
	    (ADD-FILL-GAP-AGENT-USABLE
	     (let ((name (cadr r))
		   (mach (caddr r))
		   (port (cadddr r)))
	       (add-external-fill-gap-agent-usable
		(input1l-name name)
		mach
		port)
	       t))
					;	    (PROVE
					;	     (let ((xs (cadr r)))
					;	       (let* ((x (intern xs))
					;		      (ts (get x 'timestamp)))
					;		 (if (and (claimname-p x) ts)
					;		     (if (dtype-returns-pf-p (get x 'dbtype))
					;			 (scip x)
					;		       (format t "~d does not have a proof type.~%" x))
					;		   (format t "~d is not an open claim.~%" x)))))
	    (ALL-CLAIMS
	     (let ((cl (all-claims)))
	       (scu-out (cons 'ALL-CLAIMS cl))
	       (if cl
		   (if (cdr cl)
		       (progn
			 (format t "Open Claims:~%")
			 (dolist (c cl)
			   (format t "~d~%" c)))
		     (format t "Open Claim: ~d~%" (car cl)))
		 (format t "There Are No Open Claims.~%"))
	       t))
	    (SHOW-CTX
	     (if *input1-ctx-info*
		 (dolist (xi *input1-ctx-info*)
		   (when *scunak-socket*
		     (scu-out (list 'BVAR (car xi) (cadar (cadr xi)))))
		   (format t "~d:~d~%"
			   (car xi)
			   (output1-type-string (cadar (cadr xi)))))
	       (format t "Empty Ctx~%")
	       )
	     t)
	    (CLEAR-CTX
	     (clear-bvars (mapcar #'car *input1-ctx-info*))
	     (setq *input1-ctx-info* nil)
	     (format t "Empty Ctx~%")
	     t)
	    (PUSH-CTX (push-input1-ctx) t)
	    (POP-CTX
	     (if *input1-ctx-stack*
		 (progn
		   (pop-input1-ctx)
		   (if *input1-ctx-info*
		       (format t "Most Recent In Ctx:~%~d:~d~%"
			       (caar *input1-ctx-info*)
			       (output1-type-string (cadar (cadar *input1-ctx-info*))))
		     (format t "Empty Ctx~%"))
		   t)
	       (progn
		 (format t "No previous ctx~%")
		 nil)))
	    (TYPEOF
	     (let ((pre-ex (input1l-preextr (cadr r))))
	       (multiple-value-bind
		(e newtp info fail)
		(extr-fill-in-blanks-1 pre-ex *input1-state* (input1-blanks-prefix *input1-ctx-info*))
		(if (or info fail)
		    (progn
		      (when *scunak-socket*
			(scu-out 'ILL-TYPED))
		      (format t "Could not determine a well-typed extraction term from input.~%")
		      (when fail
			(format t "~d~%" fail))
		      (dolist (z info)
			(when (eq (car z) 'EVAR) 
			  (let ((trm (nth 4 z))
				(dtp (nth 5 z))
				(etp (nth 6 z)))
			    (if (and trm dtp etp)
				(progn
				  (when *scunak-socket*
				    (scu-out (list 'TYPE-PROBLEM trm etp dtp)))
				  (format t "Term: ~d~%Has Type: ~d~%Expected Type: ~d~%"
					  (output1-extraction-string trm nil t)
					  (output1-type-string etp nil t)
					  (output1-type-string dtp nil t)))
			      (when (nth 3 z)
				(format t "~d" (nth 3 z)))))))
		      (values nil fail)
		      )
		  (if e
		    (progn
		      (when *scunak-socket*
			(scu-out (list 'TYPE newtp)))
		      (format t "Type: ~d~%" (output1-type-string newtp (mapcar #'car *input1-ctx-info*)))
		      t)
		    (progn
		      (when *scunak-socket*
			(scu-out 'ILL-TYPED))
		      (format t "Could not determine an extraction term from input.~%")
		      (values nil fail)
		      ))))))
	    (JUSTIFY
	     (let ((pre-ex (input1l-preextr (cadr r))))
	       (multiple-value-bind
		(e newtp info fail)
		(extr-fill-in-blanks-1 pre-ex *input1-state* (input1-blanks-prefix *input1-ctx-info*))
		(if (or info fail)
		    (progn
		      (when *scunak-socket*
			(scu-out 'ILL-TYPED))
		      (format t "Could not determine a well-typed extraction term from input.~%")
		      (when fail
			(format t "~d~%" fail))
		      (dolist (z info)
			(when (eq (car z) 'EVAR) 
			  (let ((trm (nth 4 z))
				(dtp (nth 5 z))
				(etp (nth 6 z)))
			    (if (and trm dtp etp)
				(progn
				  (when *scunak-socket*
				    (scu-out (list 'TYPE-PROBLEM trm etp dtp)))
				  (format t "Term: ~d~%Has Type: ~d~%Expected Type: ~d~%"
					  (output1-extraction-string trm nil t)
					  (output1-type-string etp nil t)
					  (output1-type-string dtp nil t)))
			      (when (nth 3 z)
				(format t "~d" (nth 3 z)))))))
		      (values nil fail)
		      )
		  (if (heq newtp (prop))
		      (let* ((goaltp (pf (named-term-to-db-1 (mapcar #'car *input1-ctx-info*) e)))
			     (g (quick-fill-gap (db-ctx-info *input1-ctx-info*)
						goaltp *justify-usable* t 0 nil)))
			(if g
			    (progn
			      (when *scunak-socket*
				(scu-out (list 'JUSTIFICATION (normalize (app-n-1-to-0 (length *input1-ctx-info*) (caar g))))))
			      (format t "Proof Term:~%~d~%" (output1-extraction-string 
							     (normalize (app-n-1-to-0 (length *input1-ctx-info*) (caar g)))
							     (mapcar #'car *input1-ctx-info*)
							     t))
			      t)
			  (progn
			    (when *scunak-socket*
			      (scu-out 'COULD-NOT-JUSTIFY))
			    (format t "Could not justify prop~%")
			    t)))
		    (progn
		      (when *scunak-socket*
			(scu-out 'NOT-A-PROP))
		      (format t "Given extraction was not a prop~%")
		      (values nil "Given extraction was not a prop")
		      ))))))
	    (USE
	     (let ((xl (cdr r)))
	       (setq xl (mapcar #'input1l-name xl))
	       (if (member '|all| xl)
		   (setq *justify-usable* *global-sigma*)
		 (if (member '|none| xl)
		     (setq *justify-usable* nil)
		   (progn
		     (setq *justify-usable* nil)
		     (dolist (x xl)
		       (cond ((eq x '|fo|)
			      (setq *justify-usable*
				    (union (remove-if-not #'(lambda (co)
							      (and (not (get co 'auto-gen)) (or (get co 'fo-unif-type) (get co 'fo-type))))
							  *global-sigma*)
					   *justify-usable*)))
			     ((eq x '|defns|)
			      (setq *justify-usable*
				    (union (remove-if-not #'(lambda (co)
							      (get co 'auto-gen))
							  *global-sigma*)
					   *justify-usable*)))
			     ((eq x '|so|)
			      (setq *justify-usable*
				    (union (remove-if #'(lambda (co)
							  (or (get co 'auto-gen) (get co 'fo-unif-type) (get co 'fo-type)))
						      *global-sigma*)
					   *justify-usable*)))
			     ((and (get x 'dbtype) (or (dtype-returns-dclass-p (get x 'dbtype))
						       (dtype-returns-pf-p (get x 'dbtype))))
			      (push x *justify-usable*)
			      )
			     (t (format t "Ignoring ~d~%" x)))))))
	       (if *justify-usable*
		   (format t "Reset usable~%")
		 (format t "WARNING: usable empty!~%"))
	       t))
	    (UNIF+
	     (progn
	       (format t "~d~%" (incf *preunify-msv-goal*))
	       (format t "~d~%" (incf *preunify-msv-hence*))
	       (format t "~d~%" (incf *preunify-msv-supp*))
	       t))
	    (UNIF-
	     (progn
	       (format t "~d~%" (decf *preunify-msv-goal*))
	       (format t "~d~%" (decf *preunify-msv-hence*))
	       (format t "~d~%" (decf *preunify-msv-supp*))
	       t))
	    (PROOFREAD
	     (proofread (cadr r) (input1l-newapp (caddr r)))
	     t)
	    (TUTOR-AUTO-BACK
	     (setq *tutor-auto-back* nil)
	     (dolist (n (cdr r) t)
	       (let ((c (input1l-name n)))
		 (when (get c 'dbtype)
		   (push c *tutor-auto-back*))))
	     t)
	    (TUTOR-STUDENT-USABLE
	     (setq *sig-granularity-perfect* nil)
	     (dolist (n (cdr r) t)
	       (let ((c (input1l-name n)))
		 (when (get c 'dbtype)
		   (push c *sig-granularity-perfect*))))
	     (scu-out 'OK)
	     t)
	    (TUTOR-ONLY-USABLE
	     (setq *sig-granularity-toohigh* nil)
	     (dolist (n (cdr r) t)
	       (let ((c (input1l-name n)))
		 (when (get c 'dbtype)
		   (push c *sig-granularity-toohigh*))))
	     (scu-out 'OK)
	     t)
	    (t
	     (scu-out 'NOT-COMMAND)
	     (format t "Did not understand command~%~d~%"
		     r)
	     nil))
    (progn
      (scu-out 'NOT-COMMAND)
      (format t "Did not understand command~%~d~%"
	      r)
      nil)))

(defun input1l-newapp (sl)
  (if (consp sl)
      (mapcar #'input1l-name
	      sl)
    (list (input1l-name sl))))

(defun input1l-name (s)
  (if (stringp s)
      (intern s)
    s))

(defun input1l-predtype (s)
  (if (consp s)
      (if (eq (cadr s) '->)
	  (cons 'DARR (cons (input1l-predtype (car s))
			    (input1l-predtype (caddr s))))
	(case (car s)
	      (PI (cons 'DPI (cons (input1l-name (cadr s))
				   (cons (input1l-predtype (caddr s))
					 (input1l-predtype (cadddr s))))))
	      (PF (cons 'PF (input1l-preextr (cadr s))))
	      (t (input1l-preextr s))))
    (case s
	  (PROP 'PROP)
	  (OBJ 'OBJ)
	  (t (input1l-preextr s)))))

(defun input1l-prenorm (s)
  (cond ((and (consp s) (eq (car s) 'LAM))
	 (if (and (consp (caddr s)) (eq (car (caddr s)) 'PAIR))
	     (if (consp (cadr s))
		 (cons 'LAM (cons (mapcar #'input1l-name (cadr s))
				  (cons 'PAIR
					(cons (input1l-preextr (cadr (caddr s)))
					      (input1l-preextr (caddr (caddr s)))))))
	       (cons 'LAM (cons (list (input1l-name (cadr s)))
				(cons 'PAIR
				      (cons (input1l-preextr (cadr (caddr s)))
					    (input1l-preextr (caddr (caddr s))))))))
	   (if (consp (cadr s))
	       (cons 'LAM (cons (mapcar #'input1l-name (cadr s)) (input1l-preextr (caddr s))))
	     (cons 'LAM (cons (list (input1l-name (cadr s))) (input1l-preextr (caddr s)))))))
	((and (consp s) (eq (car s) 'PAIR))
	 (cons 'PAIR (cons (input1l-preextr (cadr s))
			   (input1l-preextr (caddr s)))))
	(t (input1l-preextr s))))

(defun input1l-preextr (s)
  (cond ((or (stringp s) (symbolp s))
	 (setq s (input1l-name s))
	 (if (get s 'notation)
	     (get s 'notation)
	   s))
	((and (consp s) (= (length s) 3) (input1l-binop-p (cadr s)))
	 (let ((bop (input1l-binop (cadr s)))
	       (x (input1l-preextr (car s)))
	       (y (input1l-preextr (caddr s))))
	   (if (symbolp bop)
	       (if (eq bop '|in|)
		   (list bop y x)
		 (list bop x y))
	     (funcall bop x y))))
	((and (consp s) (input1l-binder-p (car s)))
	 (let ((bh (input1l-binder-head (car s)))
	       (nl (cadr s))
	       (bd (input1l-preextr (caddr s)))
	       (body (input1l-preextr (cadddr s))))
	   (dolist (n (if (consp nl) (reverse nl) (list nl)))
	     (setq body (list bh bd (cons 'LAM (cons (list (input1l-name n)) body)))))
	   body))
	((and (consp s) (eq (car s) 'SETOF))
	 (list '_SETCONSTRUCTOR (cadr s)
	       (input1l-preextr (caddr s))
	       (input1l-preextr (cadddr s))))
	((and (consp s) (eq (car s) 'SETOFPAIRS))
	 (list '_PAIRSETCONSTRUCTOR
	       (cadr s)
	       (caddr s)
	       (input1l-preextr (nth 3 s))
	       (input1l-preextr (nth 4 s))
	       (input1l-preextr (nth 5 s))))
	((and (consp s) (eq (car s) 'CLASSOF))
	 (list '_CLASSCONSTRUCTOR (cadr s)
	       (input1l-preextr (caddr s))))
	((and (consp s) (eq (car s) 'SETENUM))
	 (cons '_SETENUM (mapcar #'input1l-preextr (cdr s))))
	((and (consp s) (or (stringp (car s)) (symbolp (car s))))
	 (let ((h (input1l-name (car s)))
	       (y (mapcar #'input1l-prenorm (cdr s))))
	   (if (get h 'notation)
	       (append (get h 'notation) y)
	     (cons h y))))
	(t nil)))

(defun input1l-ubinop-var (b)
  (case b
	(@ '*infix-at-op*)
	(@@ '*infix-at2-op*)
	(* '*infix-star-op*)
	(** '*infix-star2-op*)
	(+ '*infix-plus-op*)
	(++ '*infix-plus2-op*)
	(- '*infix-minus-op*)
	(-- '*infix-minus2-op*)
	(/ '*infix-slash-op*)
	(// '*infix-slash2-op*)
	(< '*infix-less-op*)
	(> '*infix-greater-op*)
	))
  
(defun input1l-binop (b)
  (case b
	(!= #'(lambda (x y) (list '|not| (list '|eq| x y))))
	(== '|eq|)
	(<= '|subset|)
	(=> '|imp|)
	(<=> '|equiv|)
	(& '|and|)
	(OR '|or|)
	(IN '|in|)
	(|;| '|setadjoin|)
	(CUP '|binunion|)
	(CAP '|binintersect|)
	(TIMES '|cartprod|)
	(@ *infix-at-op*)
	(@@ *infix-at2-op*)
	(* *infix-star-op*)
	(** *infix-star2-op*)
	(+ *infix-plus-op*)
	(++ *infix-plus2-op*)
	(- *infix-minus-op*)
	(-- *infix-minus2-op*)
	(/ *infix-slash-op*)
	(// *infix-slash2-op*)
	(< *infix-less-op*)
	(> *infix-greater-op*)
	))

(defun input1l-binop-p (b)
  (member b '(!= == <= => <=> & OR IN |;| CUP CAP TIMES
		 @ @@ * ** + ++ < > - -- / //))
  )

(defun input1l-binder-p (b)
  (member b '(EXISTS FORALL EXISTS1)))

(defun input1l-binder-head (b)
  (case b
	(EXISTS '|dex|)
	(FORALL '|dall|)
	(EXISTS1 '|ex1|)))

(defun input1l-extr (e1)
  (let ((pre-ex (input1l-preextr e1)))
    (extr-fill-in-blanks-1 pre-ex *input1-state* (input1-blanks-prefix *input1-ctx-info*))))

(defun input1l-prop (e1)
  (multiple-value-bind
   (e tp)
   (input1l-extr e1)
   (if (and e tp (prop-p tp))
       e
     nil)))

(defun input1l-dtype (tp1)
  (let ((pre-dtp (input1l-predtype tp1)))
    (deptype-fill-in-blanks pre-dtp *input1-state*
			    (input1-blanks-prefix *input1-ctx-info*))))

(defun input-sig-agent (mach port info)
  (let ((s (create-socket mach port)))
    (format s "SCUNAK-INPUT~%")
    (format s "~d~%" info)
    (force-output s)
    (let ((r (read s nil nil)))
      (case r
	    (PAMELA
	     (setq r (read s nil nil))
	     (loop while r do
		   (input1l-execute r)
		   (setq r (read s nil nil)))
	     (close s))
	    (LISP
	     (setq r (read s nil nil))
	     (loop while r do
		   (eval r)
		   (setq r (read s nil nil)))
	     (close s))
	    (t
	     (format t "Unknown Input Format: ~d~%" r)
	     (scu-out 'UNKNOWN-INPUT-FORMAT)
	     (close s))))))

(defun output-sig-agent (mach port &optional info (begin 0) (end *timestamp*))
  (unless (numberp begin) (fail (format nil "Bad begin timestamp ~d" begin)))
  (unless (numberp end) (fail (format nil "Bad end timestamp ~d" end)))
  (let ((s (create-socket mach port)))
    (format s "SCUNAK-OUTPUT~%")
    (format s "~d~%" info)
    (force-output s)
    (let ((r (read s nil nil)))
      (case r
	    (PAM
	     (output1-sig (remove-if-not #'(lambda (c)
					     (and (>= (get c 'timestamp) begin)
						  (<= (get c 'timestamp) end))
					     )
					 (reverse *global-sigma*))
			  s)
	     (close s)
	     )
	    (PAM*
	     (setq *output1-skip-snd* t)
	     (output1-sig (remove-if-not #'(lambda (c)
					     (and (>= (get c 'timestamp) begin)
						  (<= (get c 'timestamp) end))
					     )
					 (reverse *global-sigma*))
			  s)
	     (setq *output1-skip-snd* nil)
	     (close s)
	     )
	    (LISP
	     (output-sig (remove-if-not #'(lambda (c)
					    (and (>= (get c 'timestamp) begin)
						 (<= (get c 'timestamp) end))
					    )
					(reverse *global-sigma*))
			 s)
	     (close s)
	     )
	    (LISP-PROPS
	     (dolist (c (reverse *global-sigma*))
	       (when (and (>= (get c 'timestamp) begin)
			  (<= (get c 'timestamp) end))
		 (format s "~S~%" (cons c (symbol-plist c)))))
	     (close s))
	    (t
	     (format t "Unknown Output Format: ~d~%" r)
	     (scu-out 'UNKNOWN-OUTPUT-FORMAT)
	     (close s))))))
